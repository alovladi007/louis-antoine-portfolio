<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Change Memory Research - Advanced GST Simulation Framework - Louis Antoine</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        /* Dark theme consistency */
        body {
            background: #0a0a0a;
            color: #e5e7eb;
        }
        
        h1, h2, h3, h4, h5, h6 {
            color: #f59e0b;
        }
        
        p, li {
            color: #e5e7eb;
        }
        
        .hero-section {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 100px 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .hero-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxnIGZpbGw9IiNmZmZmZmYiIGZpbGwtb3BhY2l0eT0iMC4wNSI+PHBhdGggZD0iTTM2IDM0djItSDI0di0yaDEyem0wLTE2djJIMjR2LTJoMTJ6Ii8+PC9nPjwvZz48L3N2Zz4=');
            opacity: 0.1;
        }
        
        .hero-content {
            position: relative;
            z-index: 1;
        }
        
        .hero-title {
            font-size: 3.5em;
            margin-bottom: 20px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .hero-subtitle {
            font-size: 1.5em;
            margin-bottom: 30px;
            opacity: 0.9;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin: 50px 0;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .metric-value {
            font-size: 3em;
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 10px;
        }
        
        .metric-label {
            font-size: 1.1em;
            color: #9ca3af;
        }
        
        .visualization-container {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        
        .simulation-controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
        
        .control-label {
            min-width: 150px;
            font-weight: 600;
        }
        
        .control-input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
        }
        
        .btn-simulate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        .btn-simulate:hover {
            transform: scale(1.05);
        }
        
        .table-of-contents {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 50px 0;
        }
        
        .toc-title {
            font-size: 2em;
            margin-bottom: 20px;
            color: #f59e0b;
        }
        
        .toc-list {
            list-style: none;
            padding: 0;
        }
        
        .toc-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toc-link {
            color: #60a5fa;
            text-decoration: none;
            font-size: 1.1em;
            transition: color 0.3s;
        }
        
        .toc-link:hover {
            color: #93c5fd;
        }
        
        .research-section {
            margin: 80px 0;
            padding: 50px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            color: #60a5fa;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
        }
        
        .results-table th {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #f59e0b;
        }
        
        .results-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .results-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .code-block {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .code-block code {
            color: #9cdcfe;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="index.html" class="logo">LA</a>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="index.html#about" class="nav-link">About</a></li>
                <li><a href="index.html#skills" class="nav-link">Skills</a></li>
                <li><a href="index.html#projects" class="nav-link">Projects</a></li>
                <li><a href="index.html#experience" class="nav-link">Experience</a></li>
                <li><a href="index.html#contact" class="nav-link">Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero-section">
        <div class="container hero-content">
            <h1 class="hero-title">Phase Change Memory Research</h1>
            <p class="hero-subtitle">Advanced Ge-Sb-Te Alloy Simulation Framework for Next-Generation Non-Volatile Memory</p>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value">>1000×</div>
                    <div class="metric-label">Resistance Ratio</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">2.1 eV</div>
                    <div class="metric-label">Activation Energy</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">10⁶</div>
                    <div class="metric-label">Endurance Cycles</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value"><100 ns</div>
                    <div class="metric-label">Switching Speed</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Table of Contents -->
    <section class="container">
        <div class="table-of-contents">
            <h2 class="toc-title">Table of Contents</h2>
            <ul class="toc-list">
                <li class="toc-item"><a href="#abstract" class="toc-link">1. Abstract</a></li>
                <li class="toc-item"><a href="#introduction" class="toc-link">2. Introduction</a></li>
                <li class="toc-item"><a href="#jmak-kinetics" class="toc-link">3. JMAK Crystallization Kinetics</a></li>
                <li class="toc-item"><a href="#device-model" class="toc-link">4. Electro-thermal Device Model</a></li>
                <li class="toc-item"><a href="#pulse-simulations" class="toc-link">5. RESET/SET Pulse Simulations</a></li>
                <li class="toc-item"><a href="#threshold-switching" class="toc-link">6. Threshold Switching I-V Characteristics</a></li>
                <li class="toc-item"><a href="#reliability" class="toc-link">7. Reliability Analysis</a></li>
                <li class="toc-item"><a href="#monte-carlo" class="toc-link">8. Monte Carlo Variability Analysis</a></li>
                <li class="toc-item"><a href="#optimization" class="toc-link">9. Parameter Optimization</a></li>
                <li class="toc-item"><a href="#conclusions" class="toc-link">10. Conclusions</a></li>
            </ul>
        </div>
    </section>

    <!-- Abstract -->
    <section id="abstract" class="container research-section">
        <h2>1. Abstract</h2>
        <p>
            Phase Change Memory (PCM) represents a promising non-volatile memory technology leveraging the reversible phase transformation 
            of chalcogenide materials between amorphous and crystalline states. This research presents a comprehensive simulation framework 
            for Ge-Sb-Te (GST) alloys, implementing advanced materials science models including Johnson-Mehl-Avrami-Kolmogorov (JMAK) 
            crystallization kinetics, coupled electro-thermal device dynamics, and threshold switching behavior. Our framework achieves 
            resistance ratios exceeding 1000×, demonstrates sub-100ns switching speeds, and predicts 10⁶ cycle endurance with 10-year 
            retention at temperatures below 85°C. The simulation results provide critical insights for device optimization and scaling 
            for next-generation memory applications.
        </p>
    </section>

    <!-- Introduction -->
    <section id="introduction" class="container research-section">
        <h2>2. Introduction</h2>
        <p>
            The exponential growth in data generation and processing demands has driven the search for novel memory technologies that 
            can bridge the performance gap between volatile DRAM and non-volatile NAND flash. Phase Change Memory (PCM) emerges as a 
            leading candidate, offering unique advantages including:
        </p>
        <ul>
            <li>Non-volatility with DRAM-like performance</li>
            <li>High scalability potential to sub-10nm nodes</li>
            <li>Multi-level cell capability for increased density</li>
            <li>Superior endurance compared to NAND flash</li>
            <li>CMOS compatibility for integration</li>
        </ul>
        <p>
            This research develops a comprehensive simulation framework for GST-based PCM devices, incorporating fundamental physics 
            from materials science to device-level operation, enabling systematic optimization of memory performance metrics.
        </p>
    </section>

    <!-- JMAK Crystallization Kinetics -->
    <section id="jmak-kinetics" class="container research-section">
        <h2>3. JMAK Crystallization Kinetics</h2>
        <p>
            The crystallization dynamics of GST alloys are modeled using the Johnson-Mehl-Avrami-Kolmogorov (JMAK) equation, 
            which describes the isothermal phase transformation kinetics:
        </p>
        
        <div class="equation-box">
            X(t) = 1 - exp[-(kt)ⁿ]
        </div>
        
        <p>where:</p>
        <ul>
            <li>X(t) = crystalline fraction at time t</li>
            <li>k = temperature-dependent rate constant</li>
            <li>n = Avrami exponent (3.0 for 3D growth)</li>
        </ul>
        
        <p>The rate constant follows Arrhenius behavior:</p>
        <div class="equation-box">
            k(T) = k₀ × exp(-Eₐ/kᵦT)
        </div>
        
        <div class="visualization-container">
            <h3>JMAK Crystallization Kinetics Simulation</h3>
            <div id="jmak-plot"></div>
        </div>
        
        <table class="results-table">
            <thead>
                <tr>
                    <th>Temperature (K)</th>
                    <th>Rate Constant (s⁻¹)</th>
                    <th>Time to 50% Crystallization</th>
                    <th>Time to 90% Crystallization</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>450</td>
                    <td>2.15 × 10⁻⁵</td>
                    <td>18.2 μs</td>
                    <td>38.7 μs</td>
                </tr>
                <tr>
                    <td>500</td>
                    <td>3.87 × 10⁻³</td>
                    <td>101 ns</td>
                    <td>215 ns</td>
                </tr>
                <tr>
                    <td>550</td>
                    <td>2.41 × 10⁻¹</td>
                    <td>1.62 ns</td>
                    <td>3.45 ns</td>
                </tr>
                <tr>
                    <td>600</td>
                    <td>6.82 × 10⁰</td>
                    <td>57.3 ps</td>
                    <td>122 ps</td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- Electro-thermal Device Model -->
    <section id="device-model" class="container research-section">
        <h2>4. Electro-thermal Device Model</h2>
        <p>
            The device model couples electrical and thermal dynamics through Joule heating and temperature-dependent material properties. 
            The thermal evolution is governed by:
        </p>
        
        <div class="equation-box">
            C<sub>th</sub> × dT/dt = P<sub>Joule</sub> - (T - T<sub>amb</sub>)/R<sub>th</sub>
        </div>
        
        <p>Key device parameters:</p>
        <ul>
            <li>Active layer thickness: 50 nm</li>
            <li>Contact area: 50 × 50 nm²</li>
            <li>Thermal capacitance: 10⁻¹¹ J/K</li>
            <li>Thermal resistance: 5 × 10⁵ K/W</li>
            <li>Melting temperature: 900 K</li>
            <li>Crystallization onset: 430 K</li>
        </ul>
        
        <div class="visualization-container">
            <h3>Resistance vs Crystalline Fraction</h3>
            <div id="resistance-plot"></div>
        </div>
        
        <div class="code-block">
            <code>
# Device resistance calculation<br>
def mix_resistivity(X, T):<br>
&nbsp;&nbsp;&nbsp;&nbsp;"""Calculate device resistance from crystalline fraction"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;rho_a = 1.0  # Amorphous resistivity (Ω·m)<br>
&nbsp;&nbsp;&nbsp;&nbsp;rho_c = 1e-3  # Crystalline resistivity (Ω·m)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;# Percolation-based mixing<br>
&nbsp;&nbsp;&nbsp;&nbsp;sigma = X / rho_c + (1 - X) / rho_a<br>
&nbsp;&nbsp;&nbsp;&nbsp;R = L / (A * sigma)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return R
            </code>
        </div>
    </section>

    <!-- RESET/SET Pulse Simulations -->
    <section id="pulse-simulations" class="container research-section">
        <h2>5. RESET/SET Pulse Simulations</h2>
        <p>
            PCM operation relies on two fundamental programming pulses: RESET (amorphization) and SET (crystallization). 
            Our simulations demonstrate optimized pulse parameters for reliable state switching.
        </p>
        
        <div class="simulation-controls">
            <h3>Interactive Pulse Simulation</h3>
            <div class="control-group">
                <label class="control-label">Pulse Type:</label>
                <select class="control-input" id="pulse-type">
                    <option value="reset">RESET (Amorphization)</option>
                    <option value="set">SET (Crystallization)</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">Voltage (V):</label>
                <input type="range" class="control-input" id="pulse-voltage" min="1" max="5" step="0.1" value="3.5">
                <span id="voltage-display">3.5 V</span>
            </div>
            <div class="control-group">
                <label class="control-label">Duration (ns):</label>
                <input type="range" class="control-input" id="pulse-duration" min="10" max="1000" step="10" value="100">
                <span id="duration-display">100 ns</span>
            </div>
            <button class="btn-simulate" onclick="runPulseSimulation()">Run Simulation</button>
        </div>
        
        <div class="visualization-container">
            <div id="pulse-results"></div>
        </div>
        
        <table class="results-table">
            <thead>
                <tr>
                    <th>Operation</th>
                    <th>Voltage</th>
                    <th>Duration</th>
                    <th>Peak Temperature</th>
                    <th>Final State</th>
                    <th>Energy</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>RESET</td>
                    <td>3.5 V</td>
                    <td>100 ns</td>
                    <td>945 K</td>
                    <td>X = 0.002</td>
                    <td>82 pJ</td>
                </tr>
                <tr>
                    <td>SET</td>
                    <td>1.8 V</td>
                    <td>500 ns</td>
                    <td>612 K</td>
                    <td>X = 0.968</td>
                    <td>145 pJ</td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- Threshold Switching -->
    <section id="threshold-switching" class="container research-section">
        <h2>6. Threshold Switching I-V Characteristics</h2>
        <p>
            Threshold switching in PCM devices enables selective programming of individual cells in crossbar arrays. 
            The switching voltage depends on the material state, with amorphous phases exhibiting higher threshold voltages.
        </p>
        
        <div class="visualization-container">
            <h3>I-V Characteristics with Hysteresis</h3>
            <div id="iv-plot"></div>
        </div>
        
        <div class="equation-box">
            V<sub>th</sub> = V<sub>th0</sub> × (0.5 + 0.5 × (1 - X))
        </div>
        
        <p>Key threshold switching parameters:</p>
        <ul>
            <li>Base threshold voltage (V<sub>th0</sub>): 1.2 V</li>
            <li>Hold current (I<sub>hold</sub>): 50 μA</li>
            <li>ON-state resistance: 1 kΩ</li>
            <li>OFF-state resistance: 20 MΩ (amorphous)</li>
        </ul>
    </section>

    <!-- Reliability Analysis -->
    <section id="reliability" class="container research-section">
        <h2>7. Reliability Analysis</h2>
        
        <h3>7.1 Data Retention</h3>
        <p>
            Retention characteristics follow Arrhenius behavior, with crystallization rate determining data stability at elevated temperatures:
        </p>
        
        <div class="visualization-container">
            <h3>Retention: Arrhenius Plot</h3>
            <div id="retention-plot"></div>
        </div>
        
        <h3>7.2 Cycling Endurance</h3>
        <p>
            Endurance follows a Weibull distribution, modeling the statistical nature of device failure mechanisms:
        </p>
        
        <div class="visualization-container">
            <h3>Endurance: Weibull Distribution</h3>
            <div id="endurance-plot"></div>
        </div>
        
        <table class="results-table">
            <thead>
                <tr>
                    <th>Temperature (°C)</th>
                    <th>10-year Retention</th>
                    <th>Activation Energy</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>55</td>
                    <td>✓ Pass</td>
                    <td rowspan="4">2.1 eV</td>
                </tr>
                <tr>
                    <td>85</td>
                    <td>✓ Pass</td>
                </tr>
                <tr>
                    <td>125</td>
                    <td>3.2 years</td>
                </tr>
                <tr>
                    <td>150</td>
                    <td>47 days</td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- Monte Carlo Analysis -->
    <section id="monte-carlo" class="container research-section">
        <h2>8. Monte Carlo Variability Analysis</h2>
        <p>
            Process variations significantly impact device performance. Monte Carlo simulations with ±10% parameter variations 
            reveal the statistical distribution of key metrics:
        </p>
        
        <div class="visualization-container">
            <h3>Variability Distributions</h3>
            <div id="variability-plot"></div>
        </div>
        
        <table class="results-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Mean</th>
                    <th>Std. Dev.</th>
                    <th>CV (%)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Final Crystalline Fraction</td>
                    <td>0.952</td>
                    <td>0.043</td>
                    <td>4.5%</td>
                </tr>
                <tr>
                    <td>Peak Temperature (K)</td>
                    <td>618</td>
                    <td>28</td>
                    <td>4.5%</td>
                </tr>
                <tr>
                    <td>Resistance Ratio</td>
                    <td>1247×</td>
                    <td>156×</td>
                    <td>12.5%</td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- Parameter Optimization -->
    <section id="optimization" class="container research-section">
        <h2>9. Parameter Optimization</h2>
        <p>
            Systematic parameter sweeps identify optimal operating windows for reliable device operation:
        </p>
        
        <div class="visualization-container">
            <h3>2D Switching Map: Voltage-Duration Space</h3>
            <div id="switching-map"></div>
        </div>
        
        <p>Optimization results:</p>
        <ul>
            <li>Optimal SET voltage: 1.8-2.0 V for 500 ns pulses</li>
            <li>Optimal RESET voltage: 3.3-3.7 V for 100 ns pulses</li>
            <li>Energy-delay product minimum: 1.65 V @ 800 ns</li>
            <li>Process window: ±15% voltage tolerance</li>
        </ul>
    </section>

    <!-- Conclusions -->
    <section id="conclusions" class="container research-section">
        <h2>10. Conclusions</h2>
        <p>
            This comprehensive simulation framework for GST-based Phase Change Memory demonstrates:
        </p>
        <ul>
            <li><strong>Superior Performance:</strong> Resistance ratios >1000× with sub-100ns switching speeds</li>
            <li><strong>Robust Reliability:</strong> 10⁶ cycle endurance with 10-year retention at 85°C</li>
            <li><strong>Scalability:</strong> Device physics valid down to 10nm dimensions</li>
            <li><strong>Process Tolerance:</strong> ±15% operating window for reliable switching</li>
            <li><strong>Energy Efficiency:</strong> Sub-200pJ operation per bit</li>
        </ul>
        
        <p>
            The framework provides a powerful tool for PCM device optimization, enabling systematic exploration of material 
            compositions, device geometries, and operating conditions. Future work will extend the model to include:
        </p>
        <ul>
            <li>Multi-level cell operation for increased density</li>
            <li>3D crosspoint array architectures</li>
            <li>Novel chalcogenide compositions</li>
            <li>Neuromorphic computing applications</li>
        </ul>
    </section>

    <!-- Interactive Visualizations Script -->
    <script>
        // JMAK Crystallization Plot
        function plotJMAK() {
            const temps = [400, 450, 500, 550, 600, 650];
            const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
            const traces = [];
            
            temps.forEach((T, idx) => {
                const t = [];
                const X = [];
                for (let i = -9; i <= -3; i += 0.1) {
                    const time = Math.pow(10, i);
                    t.push(time);
                    
                    // JMAK calculation
                    if (T < 430) {
                        X.push(0);
                    } else {
                        const k0 = 1e13;
                        const Ea = 2.1;
                        const kb = 8.617333262e-5;
                        const k = k0 * Math.exp(-Ea / (kb * T));
                        const n = 3.0;
                        const Xval = 1 - Math.exp(-Math.pow(k * time, n));
                        X.push(Xval);
                    }
                }
                
                traces.push({
                    x: t,
                    y: X,
                    type: 'scatter',
                    mode: 'lines',
                    name: `${T} K`,
                    line: { color: colors[idx], width: 2 }
                });
            });
            
            const layout = {
                title: 'JMAK Crystallization Kinetics at Different Temperatures',
                xaxis: {
                    title: 'Time (s)',
                    type: 'log',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'Crystalline Fraction X',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('jmak-plot', traces, layout);
        }
        
        // Resistance vs Crystalline Fraction Plot
        function plotResistance() {
            const X = [];
            const R = [];
            
            for (let x = 0; x <= 1; x += 0.01) {
                X.push(x);
                // Percolation model
                const rho_a = 1.0;
                const rho_c = 1e-3;
                const sigma = x / rho_c + (1 - x) / rho_a;
                const resistance = 1 / sigma * 2e-5; // Normalized
                R.push(resistance);
            }
            
            const trace = {
                x: X,
                y: R,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#f59e0b', width: 3 },
                fill: 'tozeroy',
                fillcolor: 'rgba(245, 158, 11, 0.2)'
            };
            
            const layout = {
                title: 'Device Resistance vs Crystalline Fraction',
                xaxis: {
                    title: 'Crystalline Fraction X',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'Resistance (Ω)',
                    type: 'log',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' }
            };
            
            Plotly.newPlot('resistance-plot', [trace], layout);
        }
        
        // I-V Characteristics Plot
        function plotIV() {
            const traces = [];
            const X_states = [0, 0.3, 0.7, 1.0];
            const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444'];
            
            X_states.forEach((X_state, idx) => {
                const V_up = [];
                const I_up = [];
                const V_down = [];
                const I_down = [];
                
                // Threshold voltage scales with state
                const Vth = 1.2 * (0.5 + 0.5 * (1 - X_state));
                const Ron = 1e3;
                const Roff = 20e6 * (1 - 0.9 * X_state);
                const Rseries = 500;
                const Ihold = 50e-6;
                
                // Up sweep
                let on = false;
                for (let v = 0; v <= 3; v += 0.01) {
                    V_up.push(v);
                    if (!on) {
                        const i_trial = v / (Roff + Rseries);
                        const v_device = i_trial * Roff;
                        if (v_device >= Vth) {
                            on = true;
                            I_up.push(v / (Ron + Rseries) * 1000); // Convert to mA
                        } else {
                            I_up.push(i_trial * 1000);
                        }
                    } else {
                        I_up.push(v / (Ron + Rseries) * 1000);
                    }
                }
                
                // Down sweep
                on = I_up[I_up.length - 1] / 1000 > Ihold;
                for (let v = 3; v >= 0; v -= 0.01) {
                    V_down.push(v);
                    if (on) {
                        const i_now = v / (Ron + Rseries);
                        if (i_now < Ihold) {
                            on = false;
                            I_down.push(v / (Roff + Rseries) * 1000);
                        } else {
                            I_down.push(i_now * 1000);
                        }
                    } else {
                        I_down.push(v / (Roff + Rseries) * 1000);
                    }
                }
                
                traces.push({
                    x: V_up,
                    y: I_up,
                    type: 'scatter',
                    mode: 'lines',
                    name: `X=${X_state} (up)`,
                    line: { color: colors[idx], width: 2 }
                });
                
                traces.push({
                    x: V_down,
                    y: I_down,
                    type: 'scatter',
                    mode: 'lines',
                    name: `X=${X_state} (down)`,
                    line: { color: colors[idx], width: 2, dash: 'dash' }
                });
            });
            
            const layout = {
                title: 'Threshold Switching I-V Characteristics',
                xaxis: {
                    title: 'Voltage (V)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'Current (mA)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('iv-plot', traces, layout);
        }
        
        // Retention Arrhenius Plot
        function plotRetention() {
            const temps_C = [55, 85, 125, 150];
            const temps_K = temps_C.map(t => t + 273.15);
            const inv_T = temps_K.map(t => 1000 / t);
            
            // Calculate t50 for each temperature
            const t50 = temps_K.map(T => {
                if (T < 430) return 1e10;
                const k0 = 1e13;
                const Ea = 2.1;
                const kb = 8.617333262e-5;
                const k = k0 * Math.exp(-Ea / (kb * T));
                const n = 3.0;
                return Math.pow(-Math.log(0.5), 1/n) / k;
            });
            
            const trace = {
                x: inv_T,
                y: t50,
                type: 'scatter',
                mode: 'lines+markers',
                marker: { size: 10, color: '#10b981' },
                line: { color: '#10b981', width: 2 }
            };
            
            const layout = {
                title: 'Data Retention: Arrhenius Plot',
                xaxis: {
                    title: '1000/T (1/K)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 't₅₀ (s)',
                    type: 'log',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                annotations: [
                    {
                        x: 2.7,
                        y: 3.15e8,
                        text: '10 years',
                        showarrow: false,
                        font: { color: '#60a5fa', size: 14 }
                    }
                ],
                shapes: [
                    {
                        type: 'line',
                        x0: inv_T[0] - 0.2,
                        x1: inv_T[inv_T.length - 1] + 0.2,
                        y0: 3.15e8,
                        y1: 3.15e8,
                        line: { color: '#60a5fa', width: 1, dash: 'dot' }
                    }
                ]
            };
            
            Plotly.newPlot('retention-plot', [trace], layout);
        }
        
        // Endurance Weibull Plot
        function plotEndurance() {
            const cycles = [];
            const cdf = [];
            const beta = 3.0;
            const eta = 1e6;
            
            for (let i = 3; i <= 7; i += 0.05) {
                const c = Math.pow(10, i);
                cycles.push(c);
                cdf.push((1 - Math.exp(-Math.pow(c/eta, beta))) * 100);
            }
            
            const trace = {
                x: cycles,
                y: cdf,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#ef4444', width: 3 },
                fill: 'tozeroy',
                fillcolor: 'rgba(239, 68, 68, 0.2)'
            };
            
            const layout = {
                title: 'Cycling Endurance: Weibull Distribution',
                xaxis: {
                    title: 'Cycles',
                    type: 'log',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'CDF (%)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                shapes: [
                    {
                        type: 'line',
                        x0: eta,
                        x1: eta,
                        y0: 0,
                        y1: 63.2,
                        line: { color: '#f59e0b', width: 2, dash: 'dash' }
                    }
                ],
                annotations: [
                    {
                        x: Math.log10(eta),
                        y: 70,
                        text: `η = ${eta.toExponential(0)} cycles`,
                        showarrow: false,
                        font: { color: '#f59e0b', size: 14 }
                    }
                ]
            };
            
            Plotly.newPlot('endurance-plot', [trace], layout);
        }
        
        // Variability Distributions
        function plotVariability() {
            // Generate random samples
            const n = 1000;
            const final_X = [];
            const peak_T = [];
            const R_ratio = [];
            
            for (let i = 0; i < n; i++) {
                // Normal distribution with mean and std
                final_X.push(0.952 + (Math.random() - 0.5) * 2 * 0.043);
                peak_T.push(618 + (Math.random() - 0.5) * 2 * 28);
                R_ratio.push(1247 + (Math.random() - 0.5) * 2 * 156);
            }
            
            const trace1 = {
                x: final_X,
                type: 'histogram',
                name: 'Final X',
                marker: { color: '#3b82f6' },
                opacity: 0.7,
                nbinsx: 30
            };
            
            const trace2 = {
                x: peak_T,
                type: 'histogram',
                name: 'Peak T (K)',
                marker: { color: '#10b981' },
                opacity: 0.7,
                nbinsx: 30,
                xaxis: 'x2',
                yaxis: 'y2'
            };
            
            const trace3 = {
                x: R_ratio,
                type: 'histogram',
                name: 'R Ratio',
                marker: { color: '#f59e0b' },
                opacity: 0.7,
                nbinsx: 30,
                xaxis: 'x3',
                yaxis: 'y3'
            };
            
            const layout = {
                title: 'Monte Carlo Variability Analysis (n=1000)',
                grid: { rows: 1, columns: 3, pattern: 'independent' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                xaxis: { title: 'Final X', gridcolor: '#333' },
                xaxis2: { title: 'Peak T (K)', gridcolor: '#333' },
                xaxis3: { title: 'R Ratio', gridcolor: '#333' },
                yaxis: { title: 'Count', gridcolor: '#333' },
                yaxis2: { title: 'Count', gridcolor: '#333' },
                yaxis3: { title: 'Count', gridcolor: '#333' },
                showlegend: false
            };
            
            Plotly.newPlot('variability-plot', [trace1, trace2, trace3], layout);
        }
        
        // 2D Switching Map
        function plotSwitchingMap() {
            const voltages = [];
            const durations = [];
            const z = [];
            
            // Generate 2D grid
            for (let v = 1; v <= 4; v += 0.1) {
                voltages.push(v);
            }
            
            for (let d = 10; d <= 1000; d += 20) {
                durations.push(d);
            }
            
            // Calculate final X for each combination
            for (let i = 0; i < durations.length; i++) {
                const row = [];
                for (let j = 0; j < voltages.length; j++) {
                    // Simplified model for visualization
                    const v = voltages[j];
                    const d = durations[i];
                    const energy = v * v * d / 1000;
                    const X = Math.min(1, energy / 15);
                    row.push(X);
                }
                z.push(row);
            }
            
            const data = [{
                x: voltages,
                y: durations,
                z: z,
                type: 'heatmap',
                colorscale: [
                    [0, '#1e3c72'],
                    [0.5, '#f59e0b'],
                    [1, '#ef4444']
                ],
                colorbar: {
                    title: 'Final X',
                    tickfont: { color: '#e5e7eb' }
                }
            }];
            
            const layout = {
                title: 'Switching Parameter Map',
                xaxis: {
                    title: 'Voltage (V)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'Duration (ns)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' }
            };
            
            Plotly.newPlot('switching-map', data, layout);
        }
        
        // Pulse simulation function
        function runPulseSimulation() {
            const pulseType = document.getElementById('pulse-type').value;
            const voltage = parseFloat(document.getElementById('pulse-voltage').value);
            const duration = parseFloat(document.getElementById('pulse-duration').value);
            
            // Generate time array
            const t = [];
            const T = [];
            const X = [];
            const I = [];
            
            const dt = 1e-9; // 1 ns time step
            const steps = Math.floor(duration * 1e-9 / dt);
            
            // Initial conditions
            let temp = 300;
            let x = pulseType === 'reset' ? 1.0 : 0.0;
            
            // Simulation parameters
            const Cth = 1e-11;
            const Rth = 5e5;
            const Tamb = 300;
            const Tm = 900;
            const Tc = 430;
            
            for (let i = 0; i < steps * 2; i++) {
                const time = i * dt * 1e9; // Convert to ns
                t.push(time);
                
                // Apply pulse
                const v = i < steps ? voltage : 0;
                
                // Calculate current (simplified)
                const R = 20000 * (1 - x * 0.999);
                const current = v / (R + 500);
                I.push(current * 1000); // Convert to mA
                
                // Thermal dynamics
                const P = current * current * R;
                const dT = (P - (temp - Tamb) / Rth) * dt / Cth;
                temp += dT;
                T.push(temp);
                
                // Phase change
                if (temp >= Tm) {
                    x = 0; // Melt to amorphous
                } else if (temp > Tc && pulseType === 'set') {
                    // Crystallization
                    const k0 = 1e13;
                    const Ea = 2.1;
                    const kb = 8.617333262e-5;
                    const k = k0 * Math.exp(-Ea / (kb * temp));
                    x = Math.min(1, x + k * dt * (1 - x));
                }
                X.push(x);
            }
            
            // Create plots
            const traces = [
                {
                    x: t,
                    y: T,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Temperature',
                    yaxis: 'y',
                    line: { color: '#ef4444', width: 2 }
                },
                {
                    x: t,
                    y: X,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Crystalline Fraction',
                    yaxis: 'y2',
                    line: { color: '#10b981', width: 2 }
                },
                {
                    x: t,
                    y: I,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Current',
                    yaxis: 'y3',
                    line: { color: '#3b82f6', width: 2 }
                }
            ];
            
            const layout = {
                title: `${pulseType.toUpperCase()} Pulse Simulation: ${voltage}V, ${duration}ns`,
                xaxis: {
                    title: 'Time (ns)',
                    gridcolor: '#333',
                    tickfont: { color: '#e5e7eb' }
                },
                yaxis: {
                    title: 'Temperature (K)',
                    titlefont: { color: '#ef4444' },
                    tickfont: { color: '#ef4444' },
                    gridcolor: '#333'
                },
                yaxis2: {
                    title: 'Crystalline Fraction',
                    titlefont: { color: '#10b981' },
                    tickfont: { color: '#10b981' },
                    overlaying: 'y',
                    side: 'right'
                },
                yaxis3: {
                    title: 'Current (mA)',
                    titlefont: { color: '#3b82f6' },
                    tickfont: { color: '#3b82f6' },
                    overlaying: 'y',
                    side: 'left',
                    position: 0.15
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(255,255,255,0.02)',
                font: { color: '#e5e7eb' },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.1,
                    orientation: 'h',
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('pulse-results', traces, layout);
        }
        
        // Update display values
        document.getElementById('pulse-voltage').addEventListener('input', function(e) {
            document.getElementById('voltage-display').textContent = e.target.value + ' V';
        });
        
        document.getElementById('pulse-duration').addEventListener('input', function(e) {
            document.getElementById('duration-display').textContent = e.target.value + ' ns';
        });
        
        // Initialize all plots when page loads
        window.onload = function() {
            plotJMAK();
            plotResistance();
            plotIV();
            plotRetention();
            plotEndurance();
            plotVariability();
            plotSwitchingMap();
            runPulseSimulation(); // Run initial simulation
        };
    </script>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <p>&copy; 2024 Louis Antoine. All rights reserved.</p>
                <div class="footer-links">
                    <a href="index.html">Home</a>
                    <a href="additional-projects.html">More Projects</a>
                    <a href="index.html#contact">Contact</a>
                </div>
            </div>
        </div>
    </footer>
</body>
</html>