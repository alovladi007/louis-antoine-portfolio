<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning Analytics Platform - Louis Antoine</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Inside Black Hole Background -->
    <canvas id="blackhole-interior"></canvas>
    <div class="spacetime-distortion"></div>
    
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="index.html" class="logo">LA</a>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="index.html#about" class="nav-link">About</a></li>
                <li><a href="index.html#skills" class="nav-link">Skills</a></li>
                <li><a href="index.html#projects" class="nav-link">Projects</a></li>
                <li><a href="index.html#experience" class="nav-link">Experience</a></li>
                <li><a href="index.html#contact" class="nav-link">Contact</a></li>
            </ul>
        </div>
    </nav>

    <section class="detail-page">
        <div class="container">
            <div class="back-link">
                <a href="index.html#projects"><i class="fas fa-arrow-left"></i> Back to Projects</a>
            </div>
            
            <div class="detail-header">
                <h1>Machine Learning Analytics Platform</h1>
                <p class="project-type">Predictive Maintenance & Process Optimization</p>
            </div>

            <div class="project-content">
                <div class="project-overview">
                    <h3><i class="fas fa-brain"></i> Project Overview</h3>
                    <p>Comprehensive analytics platform designed for predictive maintenance and process optimization in semiconductor manufacturing environments. The system leverages advanced machine learning algorithms to predict equipment failures, optimize maintenance schedules, and improve overall manufacturing efficiency.</p>
                </div>

                <div class="project-details-grid">
                    <div class="project-detail-section">
                        <h3><i class="fas fa-target"></i> Key Features</h3>
                        <ul class="project-details">
                            <li>Real-time equipment health monitoring</li>
                            <li>Predictive failure analysis</li>
                            <li>Automated maintenance scheduling</li>
                            <li>Process parameter optimization</li>
                            <li>Interactive dashboards and reporting</li>
                            <li>Integration with existing manufacturing systems</li>
                        </ul>
                    </div>

                    <div class="project-detail-section">
                        <h3><i class="fas fa-cogs"></i> Technical Implementation</h3>
                        <ul class="project-details">
                            <li><strong>Data Pipeline:</strong> Apache Kafka, Apache Spark</li>
                            <li><strong>ML Models:</strong> Random Forest, LSTM, XGBoost</li>
                            <li><strong>Backend:</strong> Python, FastAPI, PostgreSQL</li>
                            <li><strong>Frontend:</strong> React, D3.js, Material-UI</li>
                            <li><strong>Deployment:</strong> Docker, Kubernetes, AWS</li>
                            <li><strong>Monitoring:</strong> Prometheus, Grafana</li>
                        </ul>
                    </div>

                    <div class="project-detail-section">
                        <h3><i class="fas fa-chart-bar"></i> Results Achieved</h3>
                        <ul class="project-details">
                            <li>25% reduction in unplanned downtime</li>
                            <li>30% improvement in maintenance efficiency</li>
                            <li>15% increase in overall equipment effectiveness</li>
                            <li>$1.8M annual cost savings</li>
                            <li>92% accuracy in failure prediction</li>
                            <li>Real-time monitoring of 500+ sensors</li>
                        </ul>
                    </div>

                    <div class="project-detail-section">
                        <h3><i class="fas fa-tools"></i> Technologies Used</h3>
                        <div class="tech-tags">
                            <span class="tech-tag">Python</span>
                            <span class="tech-tag">TensorFlow</span>
                            <span class="tech-tag">Apache Spark</span>
                            <span class="tech-tag">React</span>
                            <span class="tech-tag">PostgreSQL</span>
                            <span class="tech-tag">Docker</span>
                            <span class="tech-tag">AWS</span>
                            <span class="tech-tag">Kubernetes</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <style>
        /* Subtle Black Hole Background */
        #blackhole-interior {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: linear-gradient(135deg, #0a0a0f 0%, #0f0a1a 50%, #0a0a0f 100%);
            opacity: 0.7;
        }

        .spacetime-distortion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            background: 
                radial-gradient(ellipse at center, transparent 0%, rgba(138, 43, 226, 0.03) 40%, rgba(0, 0, 0, 0.5) 100%),
                radial-gradient(circle at 30% 40%, rgba(255, 0, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 70% 60%, rgba(0, 255, 255, 0.02) 0%, transparent 50%);
            animation: distort 30s ease-in-out infinite;
        }

        @keyframes distort {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(2deg) scale(1.02); }
            50% { transform: rotate(-1deg) scale(0.99); }
            75% { transform: rotate(1deg) scale(1.01); }
        }

        .detail-page {
            padding: 120px 0 80px;
            position: relative;
            min-height: 100vh;
            color: #fff;
            background: transparent;
        }

        /* Clean, readable content sections with subtle glow */
        .project-overview,
        .project-detail-section {
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(138, 43, 226, 0.2);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.3),
                0 0 40px rgba(138, 43, 226, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .back-link {
            margin-bottom: 2rem;
        }

        .back-link a {
            color: #667eea;
            text-decoration: none;
            font-size: 1.1rem;
            transition: color 0.3s ease;
        }

        .back-link a:hover {
            color: #764ba2;
        }

        .detail-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .detail-header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .project-type {
            color: #667eea;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .project-overview {
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 3rem;
            position: relative;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .project-overview h3 {
            color: #667eea;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .project-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .project-detail-section {
            padding: 2rem;
            border-radius: 15px;
            position: relative;
            transition: transform 0.3s ease;
        }
        
        .project-detail-section:hover {
            transform: scale(1.01) translateZ(10px);
            box-shadow: 
                0 6px 25px rgba(0, 0, 0, 0.4),
                0 0 50px rgba(138, 43, 226, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .project-detail-section h3 {
            color: #667eea;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .project-details {
            list-style: none;
            padding: 0;
        }

        .project-details li {
            color: #ccc;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
            position: relative;
        }

        .project-details li::before {
            content: 'â–¶';
            color: #667eea;
            position: absolute;
            left: 0;
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
        }

        .tech-tag {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .project-details-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>

    <script src="script.js"></script>
    
    <script>
        // Inside Black Hole Animation
        const canvas = document.getElementById('blackhole-interior');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let centerX = width / 2;
        let centerY = height / 2;
        let time = 0;
        
        // Spacetime Grid
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 30;
                this.points = [];
                this.generateGrid();
            }
            
            generateGrid() {
                for (let x = 0; x <= width; x += this.gridSize) {
                    for (let y = 0; y <= height; y += this.gridSize) {
                        this.points.push({
                            baseX: x,
                            baseY: y,
                            x: x,
                            y: y
                        });
                    }
                }
            }
            
            update() {
                this.points.forEach(point => {
                    const dx = point.baseX - centerX;
                    const dy = point.baseY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = Math.min(width, height) / 2;
                    
                    // Warping effect - stronger near center
                    const warpStrength = Math.max(0, 1 - distance / maxDistance);
                    const angle = Math.atan2(dy, dx);
                    const warpAngle = angle + time * warpStrength * 0.5;
                    const warpDistance = distance * (1 - warpStrength * 0.3 * Math.sin(time * 2));
                    
                    point.x = centerX + Math.cos(warpAngle) * warpDistance;
                    point.y = centerY + Math.sin(warpAngle) * warpDistance;
                });
            }
            
                        draw() {
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.08)';
                ctx.lineWidth = 0.3;
                
                // Draw horizontal lines
                for (let y = 0; y <= height; y += this.gridSize) {
                    ctx.beginPath();
                    this.points.filter(p => Math.abs(p.baseY - y) < 1).forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                }
                
                // Draw vertical lines
                for (let x = 0; x <= width; x += this.gridSize) {
                    ctx.beginPath();
                    this.points.filter(p => Math.abs(p.baseX - x) < 1).forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                }
            }
        }
        
        // Energy Streams
        class EnergyStream {
            constructor(angle) {
                this.angle = angle;
                this.radius = 0;
                this.maxRadius = Math.sqrt(width * width + height * height);
                this.speed = 2 + Math.random() * 3;
                this.thickness = 1 + Math.random() * 3;
                this.color = this.getStreamColor();
                this.particles = [];
                this.generateParticles();
            }
            
            getStreamColor() {
                const colors = [
                    { r: 138, g: 43, b: 226 },   // Purple
                    { r: 255, g: 0, b: 255 },     // Magenta
                    { r: 0, g: 255, b: 255 },     // Cyan
                    { r: 147, g: 112, b: 219 }    // Medium Purple
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            generateParticles() {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        offset: Math.random() * Math.PI * 2,
                        distance: Math.random() * 100,
                        size: Math.random() * 2
                    });
                }
            }
            
            update() {
                this.radius += this.speed;
                if (this.radius > this.maxRadius) {
                    this.radius = 0;
                }
                
                this.particles.forEach(p => {
                    p.offset += 0.05;
                    p.distance = 50 + Math.sin(p.offset) * 30;
                });
            }
            
            draw() {
                const spiralTurns = 3;
                const angleOffset = time * 0.5;
                
                ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${0.15 * (1 - this.radius / this.maxRadius)})`;
                ctx.lineWidth = this.thickness * (1 - this.radius / this.maxRadius * 0.5) * 0.5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.2)`;
                
                ctx.beginPath();
                for (let t = 0; t <= 1; t += 0.01) {
                    const spiralAngle = this.angle + angleOffset + t * Math.PI * 2 * spiralTurns;
                    const spiralRadius = this.radius * t;
                    const wobble = Math.sin(t * Math.PI * 4 + time * 2) * 10;
                    const x = centerX + Math.cos(spiralAngle) * (spiralRadius + wobble);
                    const y = centerY + Math.sin(spiralAngle) * (spiralRadius + wobble);
                    
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw particles along the stream
                this.particles.forEach(p => {
                    const t = (this.radius + p.distance) / this.maxRadius;
                    const spiralAngle = this.angle + angleOffset + t * Math.PI * 2 * spiralTurns;
                    const spiralRadius = (this.radius + p.distance) * t;
                    const x = centerX + Math.cos(spiralAngle) * spiralRadius;
                    const y = centerY + Math.sin(spiralAngle) * spiralRadius;
                    
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${0.3 * (1 - t)})`;
                    ctx.beginPath();
                    ctx.arc(x, y, p.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.shadowBlur = 0;
            }
        }
        
        // Singularity Core
        class SingularityCore {
            constructor() {
                this.radius = 50;
                this.pulsePhase = 0;
                this.rings = [];
                this.generateRings();
            }
            
            generateRings() {
                for (let i = 0; i < 5; i++) {
                    this.rings.push({
                        radius: this.radius + i * 20,
                        rotation: Math.random() * Math.PI * 2,
                        speed: (0.02 + i * 0.01) * (i % 2 === 0 ? 1 : -1),
                        opacity: 0.5 - i * 0.08
                    });
                }
            }
            
            update() {
                this.pulsePhase += 0.03;
                this.rings.forEach(ring => {
                    ring.rotation += ring.speed;
                });
            }
            
            draw() {
                // Draw rotating rings
                this.rings.forEach(ring => {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(ring.rotation);
                    
                    const gradient = ctx.createRadialGradient(0, 0, ring.radius - 10, 0, 0, ring.radius + 10);
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(0.5, `rgba(138, 43, 226, ${ring.opacity * 0.3})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, ring.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add energy points on rings
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const x = Math.cos(angle) * ring.radius;
                        const y = Math.sin(angle) * ring.radius;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${ring.opacity * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                });
                
                // Draw subtle pulsing core
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, this.radius);
                coreGradient.addColorStop(0, `rgba(138, 43, 226, ${0.2 + Math.sin(this.pulsePhase) * 0.1})`);
                coreGradient.addColorStop(0.3, 'rgba(138, 43, 226, 0.15)');
                coreGradient.addColorStop(0.6, 'rgba(75, 0, 130, 0.1)');
                coreGradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.radius * (1 + Math.sin(this.pulsePhase) * 0.1), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Quantum Particles
        class QuantumParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.angle = Math.random() * Math.PI * 2;
                this.distance = 50 + Math.random() * 200;
                this.speed = 0.5 + Math.random() * 2;
                this.size = 1 + Math.random() * 2;
                this.lifetime = 0;
                this.maxLifetime = 100 + Math.random() * 100;
                this.color = `hsl(${260 + Math.random() * 60}, 100%, 70%)`;
            }
            
            update() {
                this.lifetime++;
                this.distance -= this.speed;
                this.angle += 0.02 / (this.distance * 0.01);
                
                if (this.distance < 20 || this.lifetime > this.maxLifetime) {
                    this.reset();
                }
            }
            
            draw() {
                const x = centerX + Math.cos(this.angle) * this.distance;
                const y = centerY + Math.sin(this.angle) * this.distance;
                const opacity = (1 - this.lifetime / this.maxLifetime) * (this.distance / 200);
                
                ctx.fillStyle = this.color.replace('70%', `70%, ${opacity}`);
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize elements
        const grid = new SpacetimeGrid();
        const streams = [];
        const particles = [];
        const singularity = new SingularityCore();
        
        // Create energy streams
        for (let i = 0; i < 6; i++) {
            streams.push(new EnergyStream((Math.PI * 2 / 6) * i));
        }
        
        // Create fewer quantum particles for subtlety
        for (let i = 0; i < 30; i++) {
            particles.push(new QuantumParticle());
        }
        
        // Animation loop
        function animate() {
            // Create subtle trailing effect
            ctx.fillStyle = 'rgba(10, 10, 15, 0.08)';
            ctx.fillRect(0, 0, width, height);
            
            time += 0.01;
            
            // Update and draw spacetime grid
            grid.update();
            grid.draw();
            
            // Update and draw energy streams
            streams.forEach(stream => {
                stream.update();
                stream.draw();
            });
            
            // Update and draw particles
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            // Draw singularity core (on top)
            singularity.update();
            singularity.draw();
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Resize handler
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            grid.generateGrid();
        });
    </script>
</body>
</html>
