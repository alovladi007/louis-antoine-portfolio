<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoT Robotics - Connection Diagnostics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, #0088ff 0%, #00ff88 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .diagnostic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .diagnostic-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1.5rem;
        }

        .diagnostic-card h2 {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #00ff88;
        }

        .status {
            padding: 0.5rem 1rem;
            border-radius: 5px;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status.checking {
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
        }

        .status.error {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status.checking .status-indicator {
            background: #ffaa00;
        }

        .status.success .status-indicator {
            background: #00ff88;
        }

        .status.error .status-indicator {
            background: #ff4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .log {
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 1rem;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            padding: 0.25rem;
        }

        .log-entry.info {
            color: #0088ff;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ffaa00;
        }

        button {
            background: linear-gradient(135deg, #0088ff 0%, #00ff88 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin-right: 1rem;
            margin-bottom: 1rem;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .data-display {
            background: rgba(0, 136, 255, 0.1);
            border: 1px solid rgba(0, 136, 255, 0.3);
            border-radius: 5px;
            padding: 1rem;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .instructions {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .instructions h3 {
            color: #00ff88;
            margin-bottom: 1rem;
        }

        .instructions ol {
            margin-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
        }

        code {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß IoT Robotics - Connection Diagnostics</h1>
        
        <div class="instructions">
            <h3>üìã Quick Setup Instructions</h3>
            <ol>
                <li>Ensure the backend is running: <code>cd iot-robotics-backend/backend && node server.js</code></li>
                <li>Check that ports 4000 (HTTP) and 4001 (WebSocket) are not blocked</li>
                <li>If running locally, use <code>http://localhost</code> or <code>http://127.0.0.1</code></li>
                <li>For remote access, ensure firewall allows connections on ports 4000-4001</li>
                <li>Click "Run All Tests" below to diagnose connection issues</li>
            </ol>
        </div>

        <div style="margin-bottom: 2rem;">
            <button onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="clearAll()">üóëÔ∏è Clear All</button>
            <button onclick="testHTTP()">üì° Test HTTP Only</button>
            <button onclick="testWebSocket()">üîå Test WebSocket Only</button>
        </div>

        <div class="diagnostic-grid">
            <!-- HTTP Connection Test -->
            <div class="diagnostic-card">
                <h2>üì° HTTP API Connection</h2>
                <div id="http-status" class="status checking">
                    <span>Checking...</span>
                    <div class="status-indicator"></div>
                </div>
                <div id="http-endpoints"></div>
                <div id="http-data" class="data-display" style="display: none;"></div>
            </div>

            <!-- WebSocket Connection Test -->
            <div class="diagnostic-card">
                <h2>üîå WebSocket Connection</h2>
                <div id="ws-status" class="status checking">
                    <span>Checking...</span>
                    <div class="status-indicator"></div>
                </div>
                <div id="ws-messages"></div>
                <div id="ws-data" class="data-display" style="display: none;"></div>
            </div>

            <!-- Robot Status -->
            <div class="diagnostic-card">
                <h2>ü§ñ Robot Status</h2>
                <div id="robot-status" class="status checking">
                    <span>Waiting for data...</span>
                    <div class="status-indicator"></div>
                </div>
                <div id="robot-data" class="data-display" style="display: none;"></div>
            </div>

            <!-- Network Diagnostics -->
            <div class="diagnostic-card">
                <h2>üåê Network Diagnostics</h2>
                <div id="network-status" class="status checking">
                    <span>Analyzing...</span>
                    <div class="status-indicator"></div>
                </div>
                <div id="network-info"></div>
            </div>
        </div>

        <div class="diagnostic-card">
            <h2>üìù Connection Log</h2>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let testResults = {};

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function updateStatus(elementId, status, message) {
            const statusEl = document.getElementById(elementId);
            statusEl.className = `status ${status}`;
            statusEl.innerHTML = `
                <span>${message}</span>
                <div class="status-indicator"></div>
            `;
        }

        async function testHTTP() {
            log('Starting HTTP API tests...', 'info');
            updateStatus('http-status', 'checking', 'Testing HTTP connection...');
            
            const endpoints = [
                { path: '/health', name: 'Health Check' },
                { path: '/api/robots', name: 'Robots API' },
                { path: '/api/robots/robot-001/state', name: 'Robot State' }
            ];
            
            let allSuccess = true;
            const results = [];
            
            for (const endpoint of endpoints) {
                try {
                    const urls = [
                        `http://localhost:4000${endpoint.path}`,
                        `http://127.0.0.1:4000${endpoint.path}`,
                        `http://${window.location.hostname}:4000${endpoint.path}`
                    ];
                    
                    let success = false;
                    let data = null;
                    
                    for (const url of urls) {
                        try {
                            log(`Testing ${endpoint.name} at ${url}...`, 'info');
                            const response = await fetch(url, { 
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache'
                            });
                            
                            if (response.ok) {
                                data = await response.json();
                                log(`‚úÖ ${endpoint.name} successful at ${url}`, 'success');
                                success = true;
                                results.push({ endpoint: endpoint.name, status: 'success', url, data });
                                break;
                            }
                        } catch (e) {
                            // Try next URL
                        }
                    }
                    
                    if (!success) {
                        log(`‚ùå ${endpoint.name} failed on all URLs`, 'error');
                        allSuccess = false;
                        results.push({ endpoint: endpoint.name, status: 'failed' });
                    }
                } catch (error) {
                    log(`‚ùå ${endpoint.name} error: ${error.message}`, 'error');
                    allSuccess = false;
                    results.push({ endpoint: endpoint.name, status: 'error', error: error.message });
                }
            }
            
            // Display results
            const endpointsEl = document.getElementById('http-endpoints');
            endpointsEl.innerHTML = results.map(r => `
                <div class="status ${r.status === 'success' ? 'success' : 'error'}" style="margin-top: 0.5rem;">
                    <span>${r.endpoint}</span>
                    <span>${r.status === 'success' ? '‚úÖ' : '‚ùå'}</span>
                </div>
            `).join('');
            
            if (allSuccess) {
                updateStatus('http-status', 'success', 'HTTP API Connected');
                const dataEl = document.getElementById('http-data');
                dataEl.style.display = 'block';
                dataEl.textContent = JSON.stringify(results[0].data, null, 2);
                testResults.http = true;
            } else {
                updateStatus('http-status', 'error', 'HTTP API Connection Failed');
                testResults.http = false;
            }
        }

        async function testWebSocket() {
            log('Starting WebSocket tests...', 'info');
            updateStatus('ws-status', 'checking', 'Testing WebSocket connection...');
            
            const urls = [
                'ws://localhost:4001',
                'ws://127.0.0.1:4001',
                `ws://${window.location.hostname}:4001`
            ];
            
            let connected = false;
            
            for (const url of urls) {
                if (connected) break;
                
                try {
                    log(`Attempting WebSocket connection to ${url}...`, 'info');
                    
                    await new Promise((resolve, reject) => {
                        ws = new WebSocket(url);
                        
                        const timeout = setTimeout(() => {
                            ws.close();
                            reject(new Error('Connection timeout'));
                        }, 5000);
                        
                        ws.onopen = () => {
                            clearTimeout(timeout);
                            connected = true;
                            log(`‚úÖ WebSocket connected to ${url}`, 'success');
                            updateStatus('ws-status', 'success', `Connected to ${url}`);
                            
                            // Subscribe to robot control
                            ws.send(JSON.stringify({
                                type: 'subscribe',
                                channel: 'robot_control'
                            }));
                            
                            resolve();
                        };
                        
                        ws.onmessage = (event) => {
                            const data = JSON.parse(event.data);
                            log(`üì® Received: ${data.type}`, 'info');
                            
                            // Display some data
                            const dataEl = document.getElementById('ws-data');
                            dataEl.style.display = 'block';
                            dataEl.textContent = JSON.stringify(data, null, 2).substring(0, 500) + '...';
                            
                            // Update robot status if relevant
                            if (data.type === 'robot_states' || data.type === 'robot_state_update') {
                                updateRobotStatus(data.payload);
                            }
                        };
                        
                        ws.onerror = (error) => {
                            clearTimeout(timeout);
                            log(`‚ùå WebSocket error on ${url}`, 'error');
                            reject(error);
                        };
                        
                        ws.onclose = () => {
                            if (connected) {
                                log('WebSocket connection closed', 'warning');
                                updateStatus('ws-status', 'error', 'Connection closed');
                            }
                        };
                    });
                } catch (error) {
                    log(`Failed to connect to ${url}: ${error.message}`, 'error');
                }
            }
            
            if (!connected) {
                updateStatus('ws-status', 'error', 'WebSocket Connection Failed');
                testResults.websocket = false;
            } else {
                testResults.websocket = true;
            }
        }

        function updateRobotStatus(data) {
            updateStatus('robot-status', 'success', 'Receiving robot data');
            const dataEl = document.getElementById('robot-data');
            dataEl.style.display = 'block';
            
            // Format robot data nicely
            let displayData = {};
            if (data['robot-001']) {
                const robot = data['robot-001'];
                displayData = {
                    robotId: robot.robotId,
                    joints: robot.jointPositions ? robot.jointPositions.map(j => j.toFixed(3)) : [],
                    position: robot.cartesianPosition ? robot.cartesianPosition.map(p => p.toFixed(3)) : [],
                    isMoving: robot.isMoving || false
                };
            }
            
            dataEl.textContent = JSON.stringify(displayData, null, 2);
        }

        async function testNetwork() {
            log('Analyzing network configuration...', 'info');
            updateStatus('network-status', 'checking', 'Analyzing network...');
            
            const info = [];
            
            // Check current location
            info.push(`Current URL: ${window.location.href}`);
            info.push(`Hostname: ${window.location.hostname}`);
            info.push(`Protocol: ${window.location.protocol}`);
            
            // Check if running locally
            const isLocal = ['localhost', '127.0.0.1', ''].includes(window.location.hostname);
            info.push(`Running locally: ${isLocal ? 'Yes' : 'No'}`);
            
            // Check for HTTPS (WebSocket might need WSS)
            if (window.location.protocol === 'https:') {
                info.push('‚ö†Ô∏è HTTPS detected - WebSocket might need WSS protocol');
                log('Warning: HTTPS page might block WS connections. Consider using WSS.', 'warning');
            }
            
            // Display network info
            const networkEl = document.getElementById('network-info');
            networkEl.innerHTML = info.map(i => `<div style="margin-top: 0.5rem;">${i}</div>`).join('');
            
            updateStatus('network-status', 'success', 'Analysis complete');
        }

        async function runAllTests() {
            log('Starting comprehensive diagnostic tests...', 'info');
            testResults = {};
            
            // Clear previous results
            clearAll();
            
            // Run tests in sequence
            await testNetwork();
            await testHTTP();
            await testWebSocket();
            
            // Summary
            log('===== TEST SUMMARY =====', 'info');
            if (testResults.http && testResults.websocket) {
                log('‚úÖ All connections successful! Backend is fully operational.', 'success');
            } else {
                if (!testResults.http) {
                    log('‚ùå HTTP API connection failed. Check if backend is running on port 4000.', 'error');
                }
                if (!testResults.websocket) {
                    log('‚ùå WebSocket connection failed. Check if port 4001 is accessible.', 'error');
                }
                log('üí° Troubleshooting tips:', 'warning');
                log('1. Ensure backend is running: cd iot-robotics-backend/backend && node server.js', 'warning');
                log('2. Check firewall settings for ports 4000-4001', 'warning');
                log('3. If using HTTPS, WebSocket might need WSS protocol', 'warning');
            }
        }

        function clearAll() {
            document.getElementById('log').innerHTML = '';
            document.getElementById('http-endpoints').innerHTML = '';
            document.getElementById('http-data').style.display = 'none';
            document.getElementById('ws-data').style.display = 'none';
            document.getElementById('robot-data').style.display = 'none';
            
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Auto-run tests on load
        window.addEventListener('load', () => {
            log('Diagnostic page loaded. Click "Run All Tests" to begin.', 'info');
        });
    </script>
</body>
</html>