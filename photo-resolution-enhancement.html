<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resolution Enhancement Suite - Advanced RET Technologies</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(0, 212, 255, 0.05));
            border-radius: 20px;
        }
        
        h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        
        .ret-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 2rem;
        }
        
        .control-panel {
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            height: fit-content;
        }
        
        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        
        .viz-panel {
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 15px;
            padding: 1rem;
        }
        
        .panel-title {
            color: #00d4ff;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group label {
            display: block;
            color: #00d4ff;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .illumination-modes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .mode-btn {
            padding: 0.5rem;
            background: #222;
            border: 1px solid #444;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.3s;
        }
        
        .mode-btn.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }
        
        .btn {
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            width: 100%;
            margin-top: 0.5rem;
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }
        
        .metrics-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .metric {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.3rem;
            color: #00d4ff;
            font-weight: bold;
        }
        
        .metric-label {
            color: #888;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }
        
        .smo-controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select {
            width: 100%;
            padding: 0.5rem;
            background: #222;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 5px;
        }
        
        .value-display {
            text-align: right;
            color: #888;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Resolution Enhancement Technologies</h1>
            <p>Off-Axis Illumination • Source Mask Optimization • Inverse Lithography • Double Patterning</p>
        </div>
        
        <div class="metrics-row">
            <div class="metric">
                <div class="metric-value" id="k1-factor">0.25</div>
                <div class="metric-label">k1 Factor</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="resolution">35</div>
                <div class="metric-label">Resolution (nm)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="nils">2.8</div>
                <div class="metric-label">NILS</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="mef">1.2</div>
                <div class="metric-label">MEF</div>
            </div>
        </div>
        
        <div class="ret-layout">
            <div class="control-panel">
                <h3 class="panel-title">
                    <i class="fas fa-lightbulb"></i> Illumination Mode
                </h3>
                
                <div class="illumination-modes">
                    <div class="mode-btn active" onclick="setIllumination('conventional')">Conv.</div>
                    <div class="mode-btn" onclick="setIllumination('annular')">Annular</div>
                    <div class="mode-btn" onclick="setIllumination('dipole')">Dipole</div>
                    <div class="mode-btn" onclick="setIllumination('quadrupole')">Quad</div>
                    <div class="mode-btn" onclick="setIllumination('quasar')">Quasar</div>
                    <div class="mode-btn" onclick="setIllumination('custom')">Custom</div>
                </div>
                
                <div class="control-group">
                    <label>Sigma Inner: <span id="sigma-inner-val">0.3</span></label>
                    <input type="range" id="sigma-inner" min="0" max="1" step="0.05" value="0.3" oninput="updateValue('sigma-inner'); updateRET()">
                </div>
                
                <div class="control-group">
                    <label>Sigma Outer: <span id="sigma-outer-val">0.9</span></label>
                    <input type="range" id="sigma-outer" min="0.1" max="1.2" step="0.05" value="0.9" oninput="updateValue('sigma-outer'); updateRET()">
                </div>
                
                <h3 class="panel-title" style="margin-top: 2rem;">
                    <i class="fas fa-magic"></i> SMO Parameters
                </h3>
                
                <div class="smo-controls">
                    <div class="control-group">
                        <label>Optimization Target</label>
                        <select id="smo-target" onchange="updateRET()">
                            <option value="nils">Maximize NILS</option>
                            <option value="dof">Maximize DOF</option>
                            <option value="mef">Minimize MEF</option>
                            <option value="balanced">Balanced</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Source Points: <span id="source-points-val">9</span></label>
                        <input type="range" id="source-points" min="4" max="25" value="9" oninput="updateValue('source-points'); updateRET()">
                    </div>
                    
                    <div class="control-group">
                        <label>Iterations: <span id="iterations-val">100</span></label>
                        <input type="range" id="iterations" min="10" max="500" step="10" value="100" oninput="updateValue('iterations'); updateRET()">
                    </div>
                </div>
                
                <h3 class="panel-title" style="margin-top: 2rem;">
                    <i class="fas fa-layer-group"></i> Pattern Type
                </h3>
                
                <div class="control-group">
                    <select id="pattern-type" onchange="updateRET()">
                        <option value="lines">Lines/Spaces</option>
                        <option value="contacts">Contact Holes</option>
                        <option value="sram">SRAM Cell</option>
                        <option value="logic">Logic Pattern</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Target CD (nm): <span id="cd-val">45</span></label>
                    <input type="range" id="cd" min="20" max="100" value="45" oninput="updateValue('cd'); updateRET()">
                </div>
                
                <button class="btn" onclick="runSMO()">
                    <i class="fas fa-rocket"></i> Run SMO
                </button>
                
                <button class="btn" onclick="runILT()">
                    <i class="fas fa-brain"></i> Run ILT
                </button>
                
                <button class="btn" onclick="exportResults()">
                    <i class="fas fa-download"></i> Export
                </button>
            </div>
            
            <div class="viz-grid">
                <div class="viz-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-sun"></i> Source Shape
                    </h3>
                    <div id="source-plot"></div>
                </div>
                
                <div class="viz-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-layer-group"></i> Mask Pattern
                    </h3>
                    <div id="mask-plot"></div>
                </div>
                
                <div class="viz-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-image"></i> Aerial Image
                    </h3>
                    <div id="aerial-plot"></div>
                </div>
                
                <div class="viz-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-chart-line"></i> Image Quality Metrics
                    </h3>
                    <div id="metrics-plot"></div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 2rem;">
            <div class="viz-panel">
                <h3 class="panel-title">
                    <i class="fas fa-microscope"></i> ILT Result Comparison
                </h3>
                <div id="ilt-comparison"></div>
            </div>
        </div>
    </div>
    
    <script>
        let currentIllumination = 'conventional';
        let sourceData = null;
        let maskData = null;
        
        function updateValue(param) {
            const element = document.getElementById(param);
            const value = element.value;
            document.getElementById(param + '-val').textContent = value;
        }
        
        function setIllumination(mode) {
            currentIllumination = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            updateRET();
        }
        
        function generateSource() {
            const size = 100;
            const sigmaInner = parseFloat(document.getElementById('sigma-inner').value);
            const sigmaOuter = parseFloat(document.getElementById('sigma-outer').value);
            const source = [];
            
            for (let i = 0; i < size; i++) {
                let row = [];
                for (let j = 0; j < size; j++) {
                    const x = (j - size/2) / (size/2);
                    const y = (i - size/2) / (size/2);
                    const r = Math.sqrt(x*x + y*y);
                    const theta = Math.atan2(y, x);
                    
                    let value = 0;
                    
                    switch(currentIllumination) {
                        case 'conventional':
                            value = r <= sigmaOuter ? 1 : 0;
                            break;
                            
                        case 'annular':
                            value = (r >= sigmaInner && r <= sigmaOuter) ? 1 : 0;
                            break;
                            
                        case 'dipole':
                            value = (Math.abs(x) < 0.3 && r >= sigmaInner && r <= sigmaOuter) ? 1 : 0;
                            break;
                            
                        case 'quadrupole':
                            const inQuad = (Math.abs(x - y) < 0.2 || Math.abs(x + y) < 0.2);
                            value = (inQuad && r >= sigmaInner && r <= sigmaOuter) ? 1 : 0;
                            break;
                            
                        case 'quasar':
                            const angle = (theta * 180 / Math.PI + 360) % 90;
                            value = (angle < 30 && r >= sigmaInner && r <= sigmaOuter) ? 1 : 0;
                            break;
                            
                        case 'custom':
                            // Freeform illumination
                            value = (Math.sin(6 * theta) > 0 && r <= sigmaOuter) ? 1 : 0;
                            break;
                    }
                    
                    row.push(value);
                }
                source.push(row);
            }
            
            return source;
        }
        
        function generateMask() {
            const size = 100;
            const patternType = document.getElementById('pattern-type').value;
            const cd = parseFloat(document.getElementById('cd').value);
            const mask = [];
            
            for (let i = 0; i < size; i++) {
                let row = [];
                for (let j = 0; j < size; j++) {
                    let value = 0;
                    
                    switch(patternType) {
                        case 'lines':
                            value = (j % (cd/2)) < (cd/4) ? 1 : 0;
                            break;
                            
                        case 'contacts':
                            const cx = j % (cd * 2) - cd;
                            const cy = i % (cd * 2) - cd;
                            value = (cx*cx + cy*cy < (cd/4)*(cd/4)) ? 1 : 0;
                            break;
                            
                        case 'sram':
                            // SRAM-like pattern
                            const sramX = j % 40;
                            const sramY = i % 40;
                            if (sramX < 10 || sramX > 30) value = 1;
                            if (sramY < 15 || sramY > 25) value = 1;
                            break;
                            
                        case 'logic':
                            // Complex logic pattern
                            value = (Math.sin(j * 0.2) > 0 && Math.cos(i * 0.2) > 0) ? 1 : 0;
                            break;
                    }
                    
                    row.push(value);
                }
                mask.push(row);
            }
            
            return mask;
        }
        
        function calculateAerialImage(source, mask) {
            const size = mask.length;
            const aerial = [];
            
            // Simplified aerial image calculation
            for (let i = 0; i < size; i++) {
                let row = [];
                for (let j = 0; j < size; j++) {
                    let intensity = 0;
                    
                    // Convolution with source
                    for (let si = -2; si <= 2; si++) {
                        for (let sj = -2; sj <= 2; sj++) {
                            const mi = i + si;
                            const mj = j + sj;
                            if (mi >= 0 && mi < size && mj >= 0 && mj < size) {
                                const sourceVal = source[50 + si*10]?.[50 + sj*10] || 0;
                                intensity += mask[mi][mj] * sourceVal;
                            }
                        }
                    }
                    
                    row.push(intensity / 25);
                }
                aerial.push(row);
            }
            
            return aerial;
        }
        
        function calculateMetrics(aerial) {
            // Calculate NILS
            let maxSlope = 0;
            for (let i = 1; i < aerial.length - 1; i++) {
                for (let j = 1; j < aerial[0].length - 1; j++) {
                    const slope = Math.abs(aerial[i][j+1] - aerial[i][j-1]) + 
                                 Math.abs(aerial[i+1][j] - aerial[i-1][j]);
                    maxSlope = Math.max(maxSlope, slope);
                }
            }
            const nils = maxSlope * 10;
            
            // Calculate MEF
            const mef = 1 + Math.random() * 0.5;  // Simplified
            
            // Calculate k1
            const wavelength = 193;
            const NA = 1.35;
            const cd = parseFloat(document.getElementById('cd').value);
            const k1 = (cd * NA) / wavelength;
            
            // Calculate resolution
            const resolution = 0.61 * wavelength / NA;
            
            return { nils, mef, k1, resolution };
        }
        
        async function runSMO() {
            const target = document.getElementById('smo-target').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            const sourcePoints = parseInt(document.getElementById('source-points').value);
            
            // Simulate SMO optimization
            let bestSource = generateSource();
            let bestMetric = 0;
            
            for (let iter = 0; iter < iterations; iter += 10) {
                // Random perturbation
                const testSource = JSON.parse(JSON.stringify(bestSource));
                const px = Math.floor(Math.random() * 100);
                const py = Math.floor(Math.random() * 100);
                testSource[py][px] = 1 - testSource[py][px];
                
                // Evaluate
                const mask = generateMask();
                const aerial = calculateAerialImage(testSource, mask);
                const metrics = calculateMetrics(aerial);
                
                let metric = 0;
                switch(target) {
                    case 'nils': metric = metrics.nils; break;
                    case 'dof': metric = 100 / metrics.mef; break;
                    case 'mef': metric = 1 / metrics.mef; break;
                    case 'balanced': metric = metrics.nils / metrics.mef; break;
                }
                
                if (metric > bestMetric) {
                    bestMetric = metric;
                    bestSource = testSource;
                }
                
                // Update progress
                if (iter % 20 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            sourceData = bestSource;
            updateRET();
            alert('SMO optimization complete!');
        }
        
        async function runILT() {
            // Simulate ILT
            const mask = generateMask();
            const target = mask;
            
            // Generate ILT-optimized mask (simplified)
            const iltMask = [];
            for (let i = 0; i < mask.length; i++) {
                let row = [];
                for (let j = 0; j < mask[0].length; j++) {
                    let value = mask[i][j];
                    
                    // Add grayscale corrections
                    if (value === 1) {
                        // Check neighbors
                        const neighbors = 
                            (mask[i-1]?.[j] || 0) + (mask[i+1]?.[j] || 0) +
                            (mask[i]?.[j-1] || 0) + (mask[i]?.[j+1] || 0);
                        
                        if (neighbors < 2) {
                            value = 1.2;  // Boost isolated features
                        } else if (neighbors === 4) {
                            value = 0.9;  // Reduce dense features
                        }
                    }
                    
                    row.push(value);
                }
                iltMask.push(row);
            }
            
            // Plot comparison
            plotILTComparison(mask, iltMask);
            alert('ILT optimization complete!');
        }
        
        function updateRET() {
            sourceData = generateSource();
            maskData = generateMask();
            const aerial = calculateAerialImage(sourceData, maskData);
            const metrics = calculateMetrics(aerial);
            
            // Update metrics display
            document.getElementById('k1-factor').textContent = metrics.k1.toFixed(2);
            document.getElementById('resolution').textContent = Math.round(metrics.resolution);
            document.getElementById('nils').textContent = metrics.nils.toFixed(1);
            document.getElementById('mef').textContent = metrics.mef.toFixed(1);
            
            // Update plots
            plotSource(sourceData);
            plotMask(maskData);
            plotAerial(aerial);
            plotMetrics();
        }
        
        function plotSource(source) {
            Plotly.newPlot('source-plot', [{
                z: source,
                type: 'heatmap',
                colorscale: [[0, '#000'], [1, '#00d4ff']],
                showscale: false
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                margin: { t: 30, b: 30, l: 30, r: 30 },
                xaxis: { showticklabels: false },
                yaxis: { showticklabels: false }
            });
        }
        
        function plotMask(mask) {
            Plotly.newPlot('mask-plot', [{
                z: mask,
                type: 'heatmap',
                colorscale: 'Greys',
                showscale: false
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                margin: { t: 30, b: 30, l: 30, r: 30 },
                xaxis: { showticklabels: false },
                yaxis: { showticklabels: false }
            });
        }
        
        function plotAerial(aerial) {
            Plotly.newPlot('aerial-plot', [{
                z: aerial,
                type: 'heatmap',
                colorscale: 'Hot',
                showscale: false
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                margin: { t: 30, b: 30, l: 30, r: 30 },
                xaxis: { showticklabels: false },
                yaxis: { showticklabels: false }
            });
        }
        
        function plotMetrics() {
            const x = ['NILS', 'MEF', 'DOF', 'Contrast'];
            const y = [
                parseFloat(document.getElementById('nils').textContent),
                parseFloat(document.getElementById('mef').textContent),
                Math.random() * 200 + 100,  // Simulated DOF
                0.8 + Math.random() * 0.2    // Simulated contrast
            ];
            
            Plotly.newPlot('metrics-plot', [{
                x: x,
                y: y,
                type: 'bar',
                marker: { color: '#00d4ff' }
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                margin: { t: 30, b: 50, l: 50, r: 30 },
                yaxis: { title: 'Value' }
            });
        }
        
        function plotILTComparison(original, ilt) {
            const data = [
                {
                    z: original,
                    type: 'heatmap',
                    colorscale: 'Greys',
                    showscale: false,
                    xaxis: 'x',
                    yaxis: 'y'
                },
                {
                    z: ilt,
                    type: 'heatmap',
                    colorscale: [[0, '#000'], [0.9, '#666'], [1, '#00d4ff'], [1.2, '#ff6b6b']],
                    showscale: false,
                    xaxis: 'x2',
                    yaxis: 'y2'
                }
            ];
            
            const layout = {
                title: 'Original (left) vs ILT Optimized (right)',
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                grid: { rows: 1, columns: 2, pattern: 'independent' }
            };
            
            Plotly.newPlot('ilt-comparison', data, layout);
        }
        
        function exportResults() {
            const data = {
                illumination: currentIllumination,
                parameters: {
                    sigmaInner: document.getElementById('sigma-inner').value,
                    sigmaOuter: document.getElementById('sigma-outer').value,
                    cd: document.getElementById('cd').value
                },
                metrics: {
                    k1: document.getElementById('k1-factor').textContent,
                    resolution: document.getElementById('resolution').textContent,
                    nils: document.getElementById('nils').textContent,
                    mef: document.getElementById('mef').textContent
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ret_results.json';
            a.click();
        }
        
        // Initialize
        window.onload = function() {
            updateRET();
        };
    </script>
</body>
</html>