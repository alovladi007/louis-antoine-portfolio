<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metamaterial Cloaking Simulation - Interactive Demo</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        body {
            background: #0a0a0a;
            color: #e5e7eb;
        }
        
        .demo-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 10px;
        }
        
        .control-group label {
            display: block;
            color: #a855f7;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .value-display {
            background: #8e24aa;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            font-size: 0.9em;
        }
        
        .visualization-panel {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .sim-button {
            background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .sim-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(147, 51, 234, 0.4);
        }
        
        .sim-button.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .info-panel {
            background: rgba(147, 51, 234, 0.1);
            border: 1px solid rgba(147, 51, 234, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .info-panel h3 {
            color: #a855f7;
            margin-top: 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #a855f7;
        }
        
        .stat-label {
            color: #9ca3af;
            margin-top: 5px;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e5e7eb;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-button.active {
            background: #8e24aa;
            border-color: #8e24aa;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../index.html" class="logo">LA</a>
            </div>
            <ul class="nav-menu">
                <li><a href="../metamaterials-research.html" class="nav-link">← Back to Research</a></li>
            </ul>
        </div>
    </nav>

    <div class="demo-container">
        <h1 style="color: #f59e0b; text-align: center; margin: 30px 0;">
            <i class="fas fa-eye-slash"></i> Electromagnetic Cloaking with Metamaterials
        </h1>

        <!-- Mode Selector -->
        <div class="mode-selector">
            <button class="mode-button active" onclick="setMode('2d')">2D Simulation</button>
            <button class="mode-button" onclick="setMode('3d')">3D Visualization</button>
            <button class="mode-button" onclick="setMode('theory')">Theory & Design</button>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <h2 style="color: #a855f7;">Cloaking Parameters</h2>
            
            <div class="control-grid">
                <div class="control-group">
                    <label>Cloak Inner Radius (λ)</label>
                    <input type="range" id="innerRadius" min="0.5" max="2" value="1" step="0.1">
                    <span class="value-display" id="innerRadiusValue">1.0</span>
                </div>
                
                <div class="control-group">
                    <label>Cloak Outer Radius (λ)</label>
                    <input type="range" id="outerRadius" min="2" max="5" value="3" step="0.1">
                    <span class="value-display" id="outerRadiusValue">3.0</span>
                </div>
                
                <div class="control-group">
                    <label>Wave Frequency (THz)</label>
                    <input type="range" id="frequency" min="0.5" max="2" value="1" step="0.01">
                    <span class="value-display" id="frequencyValue">1.00</span>
                </div>
                
                <div class="control-group">
                    <label>Incident Angle (degrees)</label>
                    <input type="range" id="angle" min="0" max="90" value="0" step="5">
                    <span class="value-display" id="angleValue">0°</span>
                </div>
                
                <div class="control-group">
                    <label>Cloak Efficiency (%)</label>
                    <input type="range" id="efficiency" min="50" max="100" value="95" step="1">
                    <span class="value-display" id="efficiencyValue">95%</span>
                </div>
                
                <div class="control-group">
                    <label>Grid Resolution</label>
                    <input type="range" id="resolution" min="50" max="200" value="100" step="10">
                    <span class="value-display" id="resolutionValue">100</span>
                </div>
            </div>
            
            <div class="button-group">
                <button class="sim-button" onclick="runSimulation()">
                    <i class="fas fa-play"></i> Run Simulation
                </button>
                <button class="sim-button" onclick="toggleAnimation()">
                    <i class="fas fa-sync"></i> Toggle Animation
                </button>
                <button class="sim-button" onclick="resetSimulation()">
                    <i class="fas fa-redo"></i> Reset
                </button>
                <button class="sim-button" onclick="compareMode()">
                    <i class="fas fa-columns"></i> Compare Mode
                </button>
                <button class="sim-button" onclick="exportResults()">
                    <i class="fas fa-download"></i> Export Results
                </button>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="scatteringStat">0.05</div>
                <div class="stat-label">Scattering Cross-Section</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="transmissionStat">98%</div>
                <div class="stat-label">Transmission</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bandwidthStat">0.3 THz</div>
                <div class="stat-label">Bandwidth</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="indexRangeStat">-2 to 2</div>
                <div class="stat-label">Index Range</div>
            </div>
        </div>

        <!-- Main Visualization -->
        <div class="visualization-panel">
            <h2 style="color: #f59e0b;">Electromagnetic Field Distribution</h2>
            <div id="mainPlot" style="height: 600px;"></div>
        </div>

        <!-- Comparison View -->
        <div class="comparison-grid" id="comparisonView" style="display: none;">
            <div class="visualization-panel">
                <h3 style="color: #f59e0b;">Without Cloak</h3>
                <div id="withoutCloakPlot" style="height: 400px;"></div>
            </div>
            <div class="visualization-panel">
                <h3 style="color: #f59e0b;">With Cloak</h3>
                <div id="withCloakPlot" style="height: 400px;"></div>
            </div>
        </div>

        <!-- Cross-Section Analysis -->
        <div class="visualization-panel">
            <h2 style="color: #f59e0b;">Field Cross-Section Analysis</h2>
            <div id="crossSectionPlot" style="height: 400px;"></div>
        </div>

        <!-- Material Parameters -->
        <div class="visualization-panel">
            <h2 style="color: #f59e0b;">Required Material Parameters</h2>
            <div id="materialPlot" style="height: 400px;"></div>
        </div>

        <!-- Theory Panel -->
        <div class="info-panel" id="theoryPanel">
            <h3>Transformation Optics Theory</h3>
            <p>The cloaking device works by guiding electromagnetic waves around an object using spatially varying material parameters derived from coordinate transformations.</p>
            
            <h4>Transformation Equations:</h4>
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; font-family: monospace;">
                r' = (b-a)/b * r + a  (radial transformation)<br>
                θ' = θ  (angular preservation)<br>
                φ' = φ  (azimuthal preservation)<br><br>
                
                Material parameters in cloak region:<br>
                ε_r = μ_r = (r-a)/r<br>
                ε_θ = μ_θ = r/(r-a)<br>
                ε_φ = μ_φ = r/(r-a) * (b/(b-a))²
            </div>
            
            <h4>Key Requirements:</h4>
            <ul style="color: #e5e7eb;">
                <li>Anisotropic permittivity and permeability tensors</li>
                <li>Gradient index profile from inner to outer radius</li>
                <li>Perfect impedance matching at boundaries</li>
                <li>Minimal absorption for high efficiency</li>
            </ul>
        </div>
    </div>

    <script>
        let animationRunning = false;
        let animationFrame = 0;
        let compareEnabled = false;
        let currentMode = '2d';
        
        // Initialize simulation
        function initializeSimulation() {
            if (currentMode === '2d') {
                create2DFieldPlot();
            } else if (currentMode === '3d') {
                create3DVisualization();
            }
            createCrossSectionPlot();
            createMaterialParameterPlot();
        }
        
        function create2DFieldPlot() {
            const resolution = parseInt(document.getElementById('resolution').value);
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            const efficiency = parseFloat(document.getElementById('efficiency').value) / 100;
            
            // Generate field data
            const fieldData = generateFieldData(resolution, innerR, outerR, efficiency, true);
            
            const data = [{
                type: 'heatmap',
                z: fieldData,
                colorscale: [
                    [0, 'rgb(0,0,100)'],
                    [0.25, 'rgb(0,100,200)'],
                    [0.5, 'rgb(0,200,100)'],
                    [0.75, 'rgb(200,200,0)'],
                    [1, 'rgb(255,0,0)']
                ],
                showscale: true,
                colorbar: {
                    title: 'Field Intensity',
                    titlefont: {color: '#9ca3af'},
                    tickfont: {color: '#9ca3af'}
                }
            }];
            
            // Add cloak boundaries
            const theta = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 100);
            
            // Inner boundary
            const innerX = theta.map(t => 50 + innerR * 10 * Math.cos(t));
            const innerY = theta.map(t => 50 + innerR * 10 * Math.sin(t));
            
            // Outer boundary
            const outerX = theta.map(t => 50 + outerR * 10 * Math.cos(t));
            const outerY = theta.map(t => 50 + outerR * 10 * Math.sin(t));
            
            data.push({
                type: 'scatter',
                x: innerX,
                y: innerY,
                mode: 'lines',
                line: {color: 'white', width: 2, dash: 'dash'},
                showlegend: false
            });
            
            data.push({
                type: 'scatter',
                x: outerX,
                y: outerY,
                mode: 'lines',
                line: {color: 'white', width: 2, dash: 'dash'},
                showlegend: false
            });
            
            const layout = {
                title: {
                    text: 'Electromagnetic Field with Metamaterial Cloak',
                    font: {color: '#f59e0b'}
                },
                xaxis: {
                    title: 'X Position',
                    scaleanchor: 'y',
                    scaleratio: 1,
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                yaxis: {
                    title: 'Y Position',
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                annotations: [{
                    x: 50,
                    y: 50,
                    text: 'Cloaked Object',
                    showarrow: false,
                    font: {color: 'white', size: 12}
                }]
            };
            
            Plotly.newPlot('mainPlot', data, layout);
        }
        
        function create3DVisualization() {
            const resolution = 50; // Lower resolution for 3D
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            
            // Generate 3D field data
            const x = [];
            const y = [];
            const z = [];
            const values = [];
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    for (let k = 0; k < resolution / 2; k++) {
                        x.push(i - resolution/2);
                        y.push(j - resolution/2);
                        z.push(k);
                        
                        const r = Math.sqrt((i-resolution/2)**2 + (j-resolution/2)**2 + k**2) / 10;
                        let value;
                        
                        if (r < innerR) {
                            value = 0; // Inside cloaked region
                        } else if (r < outerR) {
                            value = 0.5; // Cloak material
                        } else {
                            // Wave field
                            value = Math.sin(2 * Math.PI * (i/10 - animationFrame/10));
                        }
                        values.push(value);
                    }
                }
            }
            
            const data = [{
                type: 'volume',
                x: x,
                y: y,
                z: z,
                value: values,
                isomin: 0,
                isomax: 1,
                opacity: 0.1,
                surface: {count: 17},
                colorscale: 'Viridis'
            }];
            
            const layout = {
                title: {
                    text: '3D Electromagnetic Field Distribution',
                    font: {color: '#f59e0b'}
                },
                scene: {
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    },
                    xaxis: {title: 'X', gridcolor: '#374151'},
                    yaxis: {title: 'Y', gridcolor: '#374151'},
                    zaxis: {title: 'Z', gridcolor: '#374151'},
                    bgcolor: 'rgba(0,0,0,0)'
                },
                paper_bgcolor: 'rgba(0,0,0,0)'
            };
            
            Plotly.newPlot('mainPlot', data, layout);
        }
        
        function generateFieldData(resolution, innerR, outerR, efficiency, withCloak) {
            const field = [];
            const angle = parseFloat(document.getElementById('angle').value) * Math.PI / 180;
            
            for (let i = 0; i < resolution; i++) {
                const row = [];
                for (let j = 0; j < resolution; j++) {
                    const x = (j - resolution/2) / 10;
                    const y = (i - resolution/2) / 10;
                    const r = Math.sqrt(x*x + y*y);
                    
                    let value;
                    if (withCloak) {
                        if (r < innerR) {
                            // Inside cloaked region - minimal field
                            value = 0.05 * (1 - efficiency);
                        } else if (r < outerR) {
                            // Inside cloak material - guided waves
                            const theta = Math.atan2(y, x);
                            value = 0.5 * Math.sin(10 * (theta - angle)) * 
                                   (1 - (r - innerR)/(outerR - innerR));
                        } else {
                            // Outside cloak - plane wave
                            value = Math.sin(2 * Math.PI * (x * Math.cos(angle) + 
                                   y * Math.sin(angle) - animationFrame/10));
                        }
                    } else {
                        // Without cloak - scattering from object
                        if (r < innerR) {
                            value = 0; // Object blocks field
                        } else {
                            // Scattered wave pattern
                            value = Math.sin(2 * Math.PI * (x * Math.cos(angle) + 
                                   y * Math.sin(angle) - animationFrame/10)) * 
                                   (1 + 0.5 * Math.exp(-r/2) * Math.cos(4 * Math.atan2(y, x)));
                        }
                    }
                    
                    row.push(value);
                }
                field.push(row);
            }
            
            return field;
        }
        
        function createCrossSectionPlot() {
            const resolution = 200;
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            const efficiency = parseFloat(document.getElementById('efficiency').value) / 100;
            
            const x = Array.from({length: resolution}, (_, i) => (i - resolution/2) / 10);
            
            // Field along x-axis (y=0)
            const withCloak = x.map(pos => {
                const r = Math.abs(pos);
                if (r < innerR) return 0.05 * (1 - efficiency);
                if (r < outerR) return 0.5 * (1 - (r - innerR)/(outerR - innerR));
                return Math.sin(2 * Math.PI * pos);
            });
            
            const withoutCloak = x.map(pos => {
                const r = Math.abs(pos);
                if (r < innerR) return 0;
                return Math.sin(2 * Math.PI * pos) * (1 + 0.5 * Math.exp(-r/2));
            });
            
            const data = [
                {
                    x: x,
                    y: withCloak,
                    name: 'With Cloak',
                    type: 'scatter',
                    line: {color: 'green', width: 2}
                },
                {
                    x: x,
                    y: withoutCloak,
                    name: 'Without Cloak',
                    type: 'scatter',
                    line: {color: 'red', width: 2, dash: 'dash'}
                }
            ];
            
            // Add region markers
            const shapes = [
                {
                    type: 'rect',
                    x0: -innerR,
                    x1: innerR,
                    y0: -1.5,
                    y1: 1.5,
                    fillcolor: 'rgba(255,0,0,0.1)',
                    line: {width: 0}
                },
                {
                    type: 'rect',
                    x0: -outerR,
                    x1: -innerR,
                    y0: -1.5,
                    y1: 1.5,
                    fillcolor: 'rgba(147,51,234,0.1)',
                    line: {width: 0}
                },
                {
                    type: 'rect',
                    x0: innerR,
                    x1: outerR,
                    y0: -1.5,
                    y1: 1.5,
                    fillcolor: 'rgba(147,51,234,0.1)',
                    line: {width: 0}
                }
            ];
            
            const layout = {
                title: {
                    text: 'Field Cross-Section (y = 0)',
                    font: {color: '#f59e0b'}
                },
                xaxis: {
                    title: 'X Position (wavelengths)',
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                yaxis: {
                    title: 'Field Amplitude',
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                shapes: shapes,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                showlegend: true,
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: '#374151',
                    borderwidth: 1,
                    font: {color: '#e5e7eb'}
                },
                annotations: [
                    {
                        x: 0,
                        y: 1.3,
                        text: 'Object',
                        showarrow: false,
                        font: {color: '#ef4444'}
                    },
                    {
                        x: (innerR + outerR)/2,
                        y: 1.3,
                        text: 'Cloak',
                        showarrow: false,
                        font: {color: '#a855f7'}
                    }
                ]
            };
            
            Plotly.newPlot('crossSectionPlot', data, layout);
        }
        
        function createMaterialParameterPlot() {
            const r = Array.from({length: 100}, (_, i) => i * 0.05);
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            
            // Calculate required material parameters
            const eps_r = r.map(radius => {
                if (radius < innerR || radius > outerR) return 1;
                return (radius - innerR) / radius;
            });
            
            const eps_theta = r.map(radius => {
                if (radius < innerR || radius > outerR) return 1;
                return radius / (radius - innerR);
            });
            
            const eps_phi = r.map(radius => {
                if (radius < innerR || radius > outerR) return 1;
                return radius / (radius - innerR) * Math.pow(outerR / (outerR - innerR), 2);
            });
            
            const data = [
                {
                    x: r,
                    y: eps_r,
                    name: 'εᵣ = μᵣ',
                    type: 'scatter',
                    line: {color: 'blue', width: 2}
                },
                {
                    x: r,
                    y: eps_theta,
                    name: 'εθ = μθ',
                    type: 'scatter',
                    line: {color: 'red', width: 2}
                },
                {
                    x: r,
                    y: eps_phi,
                    name: 'εφ = μφ',
                    type: 'scatter',
                    line: {color: 'green', width: 2}
                }
            ];
            
            const layout = {
                title: {
                    text: 'Required Material Parameters for Perfect Cloaking',
                    font: {color: '#f59e0b'}
                },
                xaxis: {
                    title: 'Radial Position (wavelengths)',
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                yaxis: {
                    title: 'Relative Permittivity/Permeability',
                    type: 'log',
                    gridcolor: '#374151',
                    titlefont: {color: '#9ca3af'}
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                showlegend: true,
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: '#374151',
                    borderwidth: 1,
                    font: {color: '#e5e7eb'}
                },
                shapes: [
                    {
                        type: 'rect',
                        x0: innerR,
                        x1: outerR,
                        y0: 0.01,
                        y1: 100,
                        fillcolor: 'rgba(147,51,234,0.1)',
                        line: {width: 0}
                    }
                ],
                annotations: [{
                    x: (innerR + outerR)/2,
                    y: 50,
                    text: 'Cloak Region',
                    showarrow: false,
                    font: {color: '#a855f7'}
                }]
            };
            
            Plotly.newPlot('materialPlot', data, layout);
        }
        
        function runSimulation() {
            animationFrame = 0;
            initializeSimulation();
            updateStatistics();
            
            if (!animationRunning) {
                toggleAnimation();
            }
        }
        
        function toggleAnimation() {
            animationRunning = !animationRunning;
            
            if (animationRunning) {
                animate();
            }
        }
        
        function animate() {
            if (!animationRunning) return;
            
            animationFrame += 0.5;
            
            if (currentMode === '2d') {
                const resolution = parseInt(document.getElementById('resolution').value);
                const innerR = parseFloat(document.getElementById('innerRadius').value);
                const outerR = parseFloat(document.getElementById('outerRadius').value);
                const efficiency = parseFloat(document.getElementById('efficiency').value) / 100;
                
                const fieldData = generateFieldData(resolution, innerR, outerR, efficiency, true);
                
                Plotly.restyle('mainPlot', {
                    z: [fieldData]
                }, 0);
            }
            
            requestAnimationFrame(animate);
        }
        
        function resetSimulation() {
            animationRunning = false;
            animationFrame = 0;
            document.getElementById('innerRadius').value = 1;
            document.getElementById('outerRadius').value = 3;
            document.getElementById('frequency').value = 1;
            document.getElementById('angle').value = 0;
            document.getElementById('efficiency').value = 95;
            document.getElementById('resolution').value = 100;
            updateAllValues();
            initializeSimulation();
        }
        
        function compareMode() {
            compareEnabled = !compareEnabled;
            const comparisonView = document.getElementById('comparisonView');
            
            if (compareEnabled) {
                comparisonView.style.display = 'grid';
                createComparisonPlots();
            } else {
                comparisonView.style.display = 'none';
            }
        }
        
        function createComparisonPlots() {
            const resolution = 100;
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            const efficiency = parseFloat(document.getElementById('efficiency').value) / 100;
            
            // Without cloak
            const withoutCloakData = generateFieldData(resolution, innerR, outerR, efficiency, false);
            
            const data1 = [{
                type: 'heatmap',
                z: withoutCloakData,
                colorscale: 'Viridis',
                showscale: false
            }];
            
            const layout1 = {
                title: {text: 'Strong Scattering', font: {color: '#ef4444', size: 14}},
                xaxis: {visible: false},
                yaxis: {visible: false},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: {t: 40, b: 0, l: 0, r: 0}
            };
            
            Plotly.newPlot('withoutCloakPlot', data1, layout1);
            
            // With cloak
            const withCloakData = generateFieldData(resolution, innerR, outerR, efficiency, true);
            
            const data2 = [{
                type: 'heatmap',
                z: withCloakData,
                colorscale: 'Viridis',
                showscale: false
            }];
            
            const layout2 = {
                title: {text: 'Minimal Scattering', font: {color: '#10b981', size: 14}},
                xaxis: {visible: false},
                yaxis: {visible: false},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: {t: 40, b: 0, l: 0, r: 0}
            };
            
            Plotly.newPlot('withCloakPlot', data2, layout2);
        }
        
        function setMode(mode) {
            currentMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide theory panel
            document.getElementById('theoryPanel').style.display = 
                mode === 'theory' ? 'block' : 'none';
            
            // Reinitialize visualization
            if (mode !== 'theory') {
                initializeSimulation();
            }
        }
        
        function updateStatistics() {
            const efficiency = parseFloat(document.getElementById('efficiency').value);
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            const frequency = parseFloat(document.getElementById('frequency').value);
            
            // Calculate statistics
            const scattering = (100 - efficiency) / 100;
            const transmission = efficiency;
            const bandwidth = 0.3 * frequency;
            const indexMin = -(outerR / innerR);
            const indexMax = outerR / innerR;
            
            // Update display
            document.getElementById('scatteringStat').textContent = scattering.toFixed(3);
            document.getElementById('transmissionStat').textContent = transmission + '%';
            document.getElementById('bandwidthStat').textContent = bandwidth.toFixed(2) + ' THz';
            document.getElementById('indexRangeStat').textContent = 
                indexMin.toFixed(1) + ' to ' + indexMax.toFixed(1);
        }
        
        function exportResults() {
            // Generate CSV data
            const innerR = parseFloat(document.getElementById('innerRadius').value);
            const outerR = parseFloat(document.getElementById('outerRadius').value);
            const efficiency = parseFloat(document.getElementById('efficiency').value);
            
            let csvContent = "Radius,Eps_r,Eps_theta,Eps_phi,Field_Intensity\n";
            
            for (let r = 0; r <= 5; r += 0.1) {
                let eps_r = 1, eps_theta = 1, eps_phi = 1, field = 1;
                
                if (r >= innerR && r <= outerR) {
                    eps_r = (r - innerR) / r;
                    eps_theta = r / (r - innerR);
                    eps_phi = eps_theta * Math.pow(outerR / (outerR - innerR), 2);
                    field = 0.5;
                } else if (r < innerR) {
                    field = 0.05 * (1 - efficiency/100);
                }
                
                csvContent += `${r.toFixed(2)},${eps_r.toFixed(4)},${eps_theta.toFixed(4)},${eps_phi.toFixed(4)},${field.toFixed(4)}\n`;
            }
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cloaking_simulation_results.csv';
            a.click();
        }
        
        function updateAllValues() {
            document.getElementById('innerRadiusValue').textContent = 
                parseFloat(document.getElementById('innerRadius').value).toFixed(1);
            document.getElementById('outerRadiusValue').textContent = 
                parseFloat(document.getElementById('outerRadius').value).toFixed(1);
            document.getElementById('frequencyValue').textContent = 
                parseFloat(document.getElementById('frequency').value).toFixed(2);
            document.getElementById('angleValue').textContent = 
                document.getElementById('angle').value + '°';
            document.getElementById('efficiencyValue').textContent = 
                document.getElementById('efficiency').value + '%';
            document.getElementById('resolutionValue').textContent = 
                document.getElementById('resolution').value;
        }
        
        // Event listeners
        document.getElementById('innerRadius').addEventListener('input', (e) => {
            document.getElementById('innerRadiusValue').textContent = 
                parseFloat(e.target.value).toFixed(1);
            if (!animationRunning) {
                createCrossSectionPlot();
                createMaterialParameterPlot();
            }
        });
        
        document.getElementById('outerRadius').addEventListener('input', (e) => {
            document.getElementById('outerRadiusValue').textContent = 
                parseFloat(e.target.value).toFixed(1);
            if (!animationRunning) {
                createCrossSectionPlot();
                createMaterialParameterPlot();
            }
        });
        
        document.getElementById('frequency').addEventListener('input', (e) => {
            document.getElementById('frequencyValue').textContent = 
                parseFloat(e.target.value).toFixed(2);
            updateStatistics();
        });
        
        document.getElementById('angle').addEventListener('input', (e) => {
            document.getElementById('angleValue').textContent = e.target.value + '°';
        });
        
        document.getElementById('efficiency').addEventListener('input', (e) => {
            document.getElementById('efficiencyValue').textContent = e.target.value + '%';
            updateStatistics();
        });
        
        document.getElementById('resolution').addEventListener('input', (e) => {
            document.getElementById('resolutionValue').textContent = e.target.value;
        });
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            initializeSimulation();
            updateStatistics();
        });
    </script>
</body>
</html>