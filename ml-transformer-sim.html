<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Transformer - Attention-based Defect Analysis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #2a0a0a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        .container { max-width: 1600px; margin: 0 auto; padding: 2rem; }
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: rgba(239, 68, 68, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }
        h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        .btn {
            width: 100%;
            padding: 0.75rem;
            margin-top: 0.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            font-weight: 500;
            transition: all 0.3s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3);
        }
        .viz-panel {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .panel-title {
            color: #ef4444;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Vision Transformer</h1>
            <p>Attention is All You Need for Defect Detection</p>
        </div>
        
        <div style="max-width: 350px; margin: 0 auto;">
            <button class="btn" onclick="runAttention()">
                <i class="fas fa-eye"></i> Compute Attention
            </button>
            
            <button class="btn" onclick="visualizePatches()">
                <i class="fas fa-th"></i> Show Patch Embedding
            </button>
        </div>
        
        <div class="viz-panel" style="margin-top: 2rem;">
            <h3 class="panel-title">
                <i class="fas fa-brain"></i> Self-Attention Map
            </h3>
            <div id="attention-map"></div>
        </div>
    </div>
    
    <script>
        function runAttention() {
            console.log('Computing self-attention...');
            const btn = event.target;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Computing...';
            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
            
            setTimeout(() => {
                generateAttentionMap();
                generatePositionalEncoding();
                generateMultiHeadAttention();
                generateClassTokenVisualization();
                
                btn.innerHTML = '<i class="fas fa-check"></i> Attention Computed!';
                btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                
                setTimeout(() => {
                    btn.innerHTML = '<i class="fas fa-eye"></i> Compute Attention';
                    btn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                }, 2000);
            }, 1500);
        }
        
        function visualizePatches() {
            console.log('Visualizing patch embeddings...');
            const btn = event.target;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            
            setTimeout(() => {
                generatePatchEmbeddings();
                btn.innerHTML = '<i class="fas fa-check"></i> Patches Visualized!';
                
                setTimeout(() => {
                    btn.innerHTML = '<i class="fas fa-th"></i> Show Patch Embedding';
                }, 2000);
            }, 1000);
        }
        
        function generateAttentionMap() {
            const container = document.getElementById('attention-map');
            container.innerHTML = '';
            
            // Generate self-attention matrix
            const size = 16; // 16x16 patches
            const attention = [];
            
            for (let i = 0; i < size * size; i++) {
                const row = [];
                for (let j = 0; j < size * size; j++) {
                    // Create attention patterns
                    const dist = Math.abs(i - j);
                    const value = Math.exp(-dist * 0.05) + Math.random() * 0.1;
                    row.push(Math.min(1, value));
                }
                attention.push(row);
            }
            
            const data = [{
                z: attention,
                type: 'heatmap',
                colorscale: 'Hot',
                showscale: true,
                colorbar: {
                    title: 'Attention Weight'
                }
            }];
            
            const layout = {
                title: 'Self-Attention Matrix (256x256)',
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                xaxis: { title: 'Query Position', showticklabels: false },
                yaxis: { title: 'Key Position', showticklabels: false },
                width: 600,
                height: 600
            };
            
            Plotly.newPlot('attention-map', data, layout);
        }
        
        function generatePatchEmbeddings() {
            const container = document.getElementById('attention-map');
            
            // Create patch visualization container
            const patchDiv = document.createElement('div');
            patchDiv.id = 'patch-embeddings';
            patchDiv.style.marginTop = '2rem';
            container.appendChild(patchDiv);
            
            // Generate patch grid
            const patchSize = 16;
            const numPatches = 16;
            const image = [];
            
            for (let i = 0; i < numPatches * patchSize; i++) {
                const row = [];
                for (let j = 0; j < numPatches * patchSize; j++) {
                    // Create patch boundaries
                    const patchI = Math.floor(i / patchSize);
                    const patchJ = Math.floor(j / patchSize);
                    
                    // Alternate patch colors
                    let value = ((patchI + patchJ) % 2) * 0.3 + 0.3;
                    
                    // Add boundaries
                    if (i % patchSize === 0 || j % patchSize === 0) {
                        value = 1;
                    }
                    
                    row.push(value);
                }
                image.push(row);
            }
            
            const data = [{
                z: image,
                type: 'heatmap',
                colorscale: 'Viridis',
                showscale: false
            }];
            
            const layout = {
                title: 'Image Patch Decomposition (16x16 patches)',
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                xaxis: { showticklabels: false },
                yaxis: { showticklabels: false }
            };
            
            Plotly.newPlot('patch-embeddings', data, layout);
        }
        
        function generatePositionalEncoding() {
            const container = document.getElementById('attention-map');
            
            const posDiv = document.createElement('div');
            posDiv.id = 'positional-encoding';
            posDiv.style.marginTop = '2rem';
            container.appendChild(posDiv);
            
            // Generate sinusoidal positional encoding
            const seqLength = 256;
            const dModel = 512;
            const encoding = [];
            
            for (let pos = 0; pos < seqLength; pos++) {
                const row = [];
                for (let i = 0; i < dModel; i++) {
                    const angle = pos / Math.pow(10000, (2 * i) / dModel);
                    row.push(i % 2 === 0 ? Math.sin(angle) : Math.cos(angle));
                }
                encoding.push(row);
            }
            
            const data = [{
                z: encoding,
                type: 'heatmap',
                colorscale: 'RdBu',
                showscale: true,
                colorbar: {
                    title: 'Encoding Value'
                }
            }];
            
            const layout = {
                title: 'Positional Encoding Matrix',
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                xaxis: { title: 'Embedding Dimension' },
                yaxis: { title: 'Position' }
            };
            
            Plotly.newPlot('positional-encoding', data, layout);
        }
        
        function generateMultiHeadAttention() {
            const container = document.getElementById('attention-map');
            
            const multiDiv = document.createElement('div');
            multiDiv.id = 'multi-head';
            multiDiv.style.marginTop = '2rem';
            multiDiv.style.display = 'grid';
            multiDiv.style.gridTemplateColumns = 'repeat(2, 1fr)';
            multiDiv.style.gap = '1rem';
            container.appendChild(multiDiv);
            
            // Generate 4 attention heads
            const heads = 4;
            for (let h = 0; h < heads; h++) {
                const headDiv = document.createElement('div');
                headDiv.id = `head-${h}`;
                multiDiv.appendChild(headDiv);
                
                // Generate attention pattern for each head
                const size = 64;
                const attention = [];
                
                for (let i = 0; i < size; i++) {
                    const row = [];
                    for (let j = 0; j < size; j++) {
                        // Different patterns for different heads
                        let value = 0;
                        switch(h) {
                            case 0: // Local attention
                                value = Math.exp(-Math.abs(i - j) * 0.2);
                                break;
                            case 1: // Strided attention
                                value = (i % 8 === j % 8) ? 0.8 : 0.1;
                                break;
                            case 2: // Global attention
                                value = 0.3 + Math.random() * 0.2;
                                break;
                            case 3: // Diagonal attention
                                value = Math.exp(-Math.abs(i - j) * 0.1) * Math.sin(i * 0.1);
                                break;
                        }
                        row.push(value);
                    }
                    attention.push(row);
                }
                
                Plotly.newPlot(`head-${h}`, [{
                    z: attention,
                    type: 'heatmap',
                    colorscale: 'Electric',
                    showscale: false
                }], {
                    title: `Head ${h + 1}`,
                    paper_bgcolor: '#111',
                    plot_bgcolor: '#111',
                    font: { color: '#e0e0e0', size: 10 },
                    xaxis: { showticklabels: false },
                    yaxis: { showticklabels: false },
                    margin: { t: 30, b: 20, l: 20, r: 20 }
                }, {displayModeBar: false});
            }
        }
        
        function generateClassTokenVisualization() {
            const container = document.getElementById('attention-map');
            
            const clsDiv = document.createElement('div');
            clsDiv.id = 'class-token';
            clsDiv.style.marginTop = '2rem';
            container.appendChild(clsDiv);
            
            // Generate class token attention to patches
            const numPatches = 256;
            const attention = [];
            
            for (let i = 0; i < 16; i++) {
                const row = [];
                for (let j = 0; j < 16; j++) {
                    // Class token attends more to certain regions
                    const cx = 8, cy = 8;
                    const dist = Math.sqrt(Math.pow(i - cx, 2) + Math.pow(j - cy, 2));
                    const value = Math.exp(-dist * 0.2) + Math.random() * 0.2;
                    row.push(value);
                }
                attention.push(row);
            }
            
            const data = [{
                z: attention,
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                colorbar: {
                    title: 'CLS Attention'
                }
            }];
            
            const layout = {
                title: 'Class Token Attention to Image Patches',
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#e0e0e0' },
                xaxis: { title: 'Patch Column', dtick: 1 },
                yaxis: { title: 'Patch Row', dtick: 1 }
            };
            
            Plotly.newPlot('class-token', data, layout);
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            console.log('Initializing Vision Transformer demo...');
            generateAttentionMap();
        });
    </script>
</body>
</html>